
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

import StringIO
import sys
import unittest2 as unittest
import pkg_resources
import subprocess
import os
import time
from shutil import copy, rmtree
from tempfile import mkdtemp
from turbogears.database import session, get_engine
from bkr.server.tools import ipxe_image
from bkr.server.tools.log_delete import legacy_main
from bkr.server.tools.repo_update import update_repos
from bkr.server.tests import data_setup
from bkr.server.model import OSMajor

class LogDelete(unittest.TestCase):
    """Tests the log_delete.py script"""

    def setUp(self):
        pass

    def tearDown(self):
        pass

    def test_deprecated_command(self):
        # This is currently how we test if we are in a dogfood task.
        if 'BEAKER_LABCONTROLLER_HOSTNAME' in os.environ:
            p = subprocess.Popen(['/usr/bin/log-delete', '--dry-run'], stderr=subprocess.PIPE)
            _, err = p.communicate()
            self.assertIn('DeprecationWarning: Use beaker-log-delete instead', err)
            self.assertEquals(p.returncode, 0)
        else:
            faux_stderr = StringIO.StringIO()
            orig_stderr = sys.stderr
            try:
                sys.stderr = faux_stderr
                returncode = legacy_main(['--dry-run'])
                faux_stderr.seek(0)
                output = faux_stderr.read()
                self.assertIn(
                    'DeprecationWarning: Use beaker-log-delete instead', output)
                self.assertEquals(returncode, 0)
            finally:
                sys.stderr = orig_stderr
                faux_stderr.close()


class RepoUpdate(unittest.TestCase):
    """Tests the repo_update.py script"""

    def setUp(self):
        pass

    def tearDown(self):
        pass

    def _create_remote_harness(self, base_path, name):
        tmp_dir = os.path.join(base_path, name)
        os.mkdir(tmp_dir)
        rpm_file = pkg_resources.resource_filename('bkr.server.tests', \
            'tmp-distribution-beaker-task_test-2.0-5.noarch.rpm')
        copy(rpm_file, tmp_dir)
        p = subprocess.Popen(['createrepo', '-q',
            '--checksum', 'sha', '.'], cwd=tmp_dir,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        _, err = p.communicate()
        self.assertEqual(p.returncode, 0, err)

    def test_update_harness_repos(self):
        """Test that the update_repo() call runs as expected.

        This checks that the harness repos that are supposed to be
        synced are actually synced.

        Does not check repo metadata.
        """
        if 'sqlite' in get_engine().name:
            raise unittest.SkipTest('SQL generated by lazy_create is not valid'
                ' in sqlite')
        base_path = mkdtemp()
        self.addCleanup(rmtree, base_path)
        faux_remote_harness1 = self._create_remote_harness(base_path, 'foobangmajor')
        faux_remote_harness2 = self._create_remote_harness(base_path, 'foobazmajor')
        faux_local_harness = mkdtemp('local_harness')
        self.addCleanup(rmtree, faux_local_harness)
        with session.begin():
            lab_controller = data_setup.create_labcontroller(fqdn=u'dummylab.example.invalid')
            distro_tree = data_setup.create_distro_tree(
                                osmajor=OSMajor.lazy_create(osmajor=u'foobangmajor'),
                                harness_dir=False,
                                lab_controllers=[lab_controller])
            distro_tree = data_setup.create_distro_tree(
                                osmajor=OSMajor.lazy_create(osmajor=u'foobazmajor'),
                                harness_dir=False,
                                lab_controllers=[lab_controller])
        # I'm not testing the config here, so just use createrepo
        update_repos('file://%s/' % base_path, faux_local_harness)
        self.assertTrue(os.path.exists(os.path.join(faux_local_harness, 'foobangmajor')))
        self.assertTrue(os.path.exists(os.path.join(faux_local_harness, 'foobazmajor')))

    # https://bugzilla.redhat.com/show_bug.cgi?id=1027516
    def test_does_not_run_createrepo_unnecessarily(self):
        if 'sqlite' in get_engine().name:
            raise unittest.SkipTest('SQL generated by lazy_create is not valid'
                ' in sqlite')
        osmajor = u'GreenBeretLinux99'
        with session.begin():
            lab_controller = data_setup.create_labcontroller(fqdn=u'dummylab.example.invalid')
            distro_tree = data_setup.create_distro_tree(osmajor=OSMajor.lazy_create(osmajor=osmajor),
                                                        harness_dir=False,
                                                        lab_controllers=[lab_controller])
        remote_harness_dir = mkdtemp(suffix='remote')
        self.addCleanup(rmtree, remote_harness_dir)
        local_harness_dir = mkdtemp(suffix='local')
        self.addCleanup(rmtree, local_harness_dir)
        self._create_remote_harness(remote_harness_dir, osmajor)
        # run it once, repo is built
        update_repos('file://%s/' % remote_harness_dir, local_harness_dir)
        repodata_dir = os.path.join(local_harness_dir, osmajor, 'repodata')
        mtime = os.path.getmtime(repodata_dir)
        # run it again, repo should not be rebuilt
        time.sleep(0.001)
        update_repos('file://%s/' % remote_harness_dir, local_harness_dir)
        self.assertEquals(os.path.getmtime(repodata_dir), mtime)

    # https://bugzilla.redhat.com/show_bug.cgi?id=1213225
    def test_exclude_nonexistent_osmajor(self):
        if 'sqlite' in get_engine().name:
            raise unittest.SkipTest('SQL generated by lazy_create is not valid'
                ' in sqlite')
        with session.begin():
            osmajor = OSMajor.lazy_create(osmajor="exist")
            lab_controller = data_setup.create_labcontroller(fqdn=u'dummylab.example.invalid')
            distro_tree = data_setup.create_distro_tree(osmajor=osmajor.osmajor,
                                                        harness_dir=False,
                                                        lab_controllers=[lab_controller])
            nonexistent_osmajor = OSMajor.lazy_create(osmajor=u'notexist')
        remote_harness_dir = mkdtemp(suffix='remote')
        self.addCleanup(rmtree, remote_harness_dir)
        local_harness_dir = mkdtemp(suffix='local')
        self.addCleanup(rmtree, local_harness_dir)
        self._create_remote_harness(remote_harness_dir, osmajor.osmajor)
        update_repos('file://%s/' % remote_harness_dir, local_harness_dir)
        self.assertTrue(os.path.exists(os.path.join(local_harness_dir, osmajor.osmajor)))
        self.assertFalse(os.path.exists(os.path.join(local_harness_dir, nonexistent_osmajor.osmajor)))


class IpxeImageTest(unittest.TestCase):

    def list_msdos_filesystem(self, image_filename):
        mdir = subprocess.Popen(['mdir', '-i', image_filename, '-/', '-b', '::'],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = mdir.communicate()
        if mdir.returncode != 0:
            raise RuntimeError('mdir failed: %s' % err)
        return out.splitlines()

    def test_image_generation(self):
        f = ipxe_image.generate_image()
        self.assertItemsEqual(
                self.list_msdos_filesystem(f.name),
                ['::/syslinux.cfg', '::/ipxe.lkrn'])
