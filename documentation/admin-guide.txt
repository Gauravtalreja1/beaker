% Administration Guide
<!-- vim: set filetype=markdown : -->

Scope of Document
=================

The document is aimed at experienced system administrators with basic
understanding of Linux based testing tools. This section provides
general Beaker overview information. Here you will find descriptions of
the Beaker components, Beaker architecture, Beaker server and target
host comparisons, and platform requirements.

Audience
========

This guide is primarily aimed at those who have to administer and
configure the Beaker server or lab controllers.

Beaker Architecture
===================

Beaker is an automated software testing application that allows users to
store, manage, run and review the results of customized tasks. A task is
a script that performs a specific task (or multiple tasks) and presents
these task results to the user. These tasks consist of code, data, meta
data, shell scripts, hooks to other code, and additional packages (or
dependencies). Beaker provides an interactive web application and shell
based client to do this.

Although tasks can be written in any language that is supported by the
target host, environments such as `rhts-devel` and `beakerlib` are often
used. Tasks are written and (ideally) tested before being packaged and
uploaded to the server. Once they are uploaded to the server, they are
then available to deploy to a target host. The `stdout` of a task
executing on a target host is captured and made available via the beaker
web application.

Scheduler
---------

The Beaker scheduler co-ordinates the target host systems that will
ultimately run the tasks. It manages system selection and the
co-ordination of multiple hosts if the job specifications require them.
It also manages the schedule of when recipes are run. Currently it
operates on a simple FIFO queue. The scheduler does allow some recipes
to be prioritized over one another in a non FIFO fashion. This can
happen if the recipe matches only one system (priority is bumped by one
level), or if the priority is manually set (in which case it can also be
set lower).

Server and target host relationship
-----------------------------------

The server hosts the scheduler, the task repository and the web
application. Optionally, the lab controllers and database can also live
on the server. The target host makes requests to the server for packages
that it needs to create and setup the local test environment, and run
the the tasks specified in its recipe. These are run locally on the
target host.

![ Server and target host relationship
](./images/guide/beaker_server_host.png)

The target host runs only one recipe at a time, and before each recipe
is run it is re-provisioned with a fresh distro install. As such, the
target host reports the results back to the server; It does not store
them locally.

Database
--------

The Beaker database is responsible for storing inventory, users and
groups, jobs, historical activity, task results and more. It is
configured in `/etc/beaker/server.cfg` (or an alternative configuration
file if one has been specified) with the `sqlalchemy.dburi` key. Any
database type that is supported by sqlalchemy can be used, however the
test suite is only run performed against MySQL.

Chronological Overview
======================

This section describes how a user creates a script and integrates it
into the Beaker environment:

-   On a workstation, a user writes a script and then tests the code.

-   The user builds an RPM and submits it to the repository (If they are
    using one).

-   They add their task to Beaker's task library.

-   They create a job that uses the task.

-   The scheduler will then provision a system for the tasks to run on.

-   -   The task results are sent back to the scheduler for reporting.

-   The scheduler uses email to notify the users' of their task results.

![ Chronological Overview ](./images/guide/chronological_overview.png)

System Requirements
===================

There are separate system requirements for the Beaker server and target
hosts. Due to the large number of test files that users can store in the
database, Beaker requires a multiple terabyte disk storage system.

Your Beaker server should have:

-   Red Hat Enterprise Linux 5 or latest Fedora operating system.

-   200 or more gigabytes hard disk space.

-   4 or more gigabytes of RAM.

-   4 or more CPUS running at 2.5Ghz or higher.

-   2 or more terabytes tree storage requirement.

<div class='admonition'>
**Note**

If your site already has an existing repository of Red Hat install
trees, you do not have to meet the tree storage requirement above.

</div>

Your target hosts are required to have:

-   Network connectivity to a system running a DHCP server.

-   Network booting capability (like PXE or Netboot).

-   Serial console logging support using a Target Host's management
    adapter or a terminal server such as the Avocent ACS series.

-   KVM support.

Your target hosts to need include a power controller. Here are some the
most common compatible controllers that are available:

-   HP iLO

-   Dell DRAC

-   WTI Boot bars

-   IPMI 1.5 (or higher)

-   APC

You may mix and match any of these controllers on the target hosts, but
you must include at least one of per system. Beaker supports the cman
package's fence component. Beaker supports any device that you control
from the Red Hat Enterprise Linux 5 command line.

Beaker Interface for Administrators
===================================

Some functionality in Beaker’s web interface is restricted to
administrators. Most of this functionality is accessed from the "Admin"
menu.

Groups
------

Users can be grouped together in groups. A user can belong to one or
more groups. Similarly, a system can belong to one or more groups. If a
shared system belongs to a group, it can only be used by members of that
group.

*Adding a Group*.\
To add a new group, go to "Admin -> Groups" and click the "Add ( + )" link
at the bottom left. You'll then be prompted to enter a "Display Name"
and a "Group Name". The former is the name that users of Beaker will
see, and the latter is the name used internally. It's fine to have these
names the same, or different.

*Editing a Group*.\
To edit a group, go to "Admin -> Groups" and click on the name of the
group you wish to edit. From here you can add users, systems, and
permisions to the group, as well as changing its display name and group
name.

*Group Activity*.\
To search through the historical activity of all groups, navigate to
"Activity -> Groups".

Configuration
-------------

Some Beaker configuration is stored in the database rather than in the
server config file, and can be changed without restarting Beaker
services. Go to "Admin -> Configuration" to view and change settings.

Customizing Kickstarts
======================

When Beaker provisions a system, the Beaker server generates an Anaconda
kickstart from a template file. Beaker’s kickstart templates are written
in the Jinja2 templating language. Refer to the [Jinja2
documentation](http://jinja.pocoo.org/docs/) for details of the template
syntax and builtin constructs which are available to all templates.

Beaker selects a base kickstart template according to the major version
of the distro being provisioned, for example `Fedora16` or
`RedHatEnterpriseLinux6`. If no template is found under this name,
Beaker will also try the major version with trailing digits stripped
(`Fedora`, `RedHatEnterpriseLinux`).

The Beaker server searches the following directories for kickstart
templates, in order:

-   `/etc/beaker/kickstarts`

    Custom templates may be placed here.

-   `/usr/lib/python2.6/site-packages/bkr/server/kickstarts`

    These templates are packaged with Beaker and should not be modified.

Beaker ships with kickstart templates for all current Fedora and Red Hat
Enterprise Linux distros. The shipped templates include all the
necessary parts to run Beaker scheduled jobs. They also provide a
mechanism for customizing the generated kickstarts with template
"snippets". Administrators are recommended to use custom snippets where
necessary, rather than customizing the base templates.

Kickstart Snippets
------------------

Each snippet provides a small unit of functionality within the
kickstart. The name and purpose of all defined snippets are given below.

For the following snippets Beaker ships a default template, which should
be sufficient in most cases. However, administrators may choose to
override these if necessary.

`print_anaconda_repos`
:   Provides the `repo` kickstart commands which tell Anaconda where to
    find the distro tree’s Yum repositories for installation. This
    includes any custom repos passed in the job xml as well, ie.
    `<repo name="repo_id" url="http://server/path/to/repo"/>`

`install_method`
:   Provides the `url` or `nfs` kickstart command which tells Anaconda
    where to find the distro tree for installation.

`lab_env`
:   Sets environment variables on the installed system, giving the
    address of various services within the lab. The exact name and
    meaning of the environment variables are left up to the
    administrator, but may include for example build servers, download
    servers, or temporary storage servers.

`post_s390_reboot`
:   Reportedly this does not work and should probably be deleted.

`pre_anamon`; `post_anamon`
:   Configures anamon, a small daemon which runs during the Anaconda
    install process and uploads log files to the Beaker scheduler.

`print_repos`
:   Sets up the system’s Yum repo configuration after install.

`readahead_packages`; `readahead_sysconfig`
:   Disables readahead, which is known to conflict with auditd.

`rhts_devices`; `rhts_scsi_ethdevices`
:   Provides `device` commands (if necessary) which tell Anaconda to
    load additional device modules.

`rhts_packages`
:   Provides a list of packages to be installed by Anaconda, based on
    the packages required by and requested in the recipe.

`rhts_pre`; `rhts_post`
:   Scripts necessary for running a Beaker recipe on the system after it
    is provisioned. These should never be overriden by the
    administrator.

`ssh_keys`
:   Adds the Beaker user’s SSH public keys to
    `/root/.ssh/authorized_keys` after installation, so that they can
    log in using SSH key authentication.

`timezone`
:   Provides the `timezone` kickstart command. The default timezone is
    "America/New_York". Administrators may wish to customize this on a per-lab
    basis to match the local timezone of the lab

The following snippets have no default template, and will be empty
unless customized by the administrator:

`network`
:   Provides extra network configuration parameters for Anaconda.

`packages`
:   Can be used to append extra packages to the `%packages` section of
    the kickstart.

`system`; `<distro_major_version>`
:   Can be used to insert extra Anaconda commands into the main section
    of the kickstart.

`system_pre`; `<distro_major_version>_pre`
:   Can be used to insert extra shell commands into the %pre section of
    the kickstart.

`system_post`; `<distro_major_version>_post`
:   Can be used to insert extra shell commands into the %post section of
    the kickstart.

When a snippet is included in a kickstart template, Beaker tries to load
the snippet from the following locations on the server’s filesystem, in
order:

-   `/etc/beaker/snippets/per_system/<snippet_name>/<system_fqdn>`

-   `/etc/beaker/snippets/per_lab/<snippet_name>/<labcontroller_fqdn>`

-   `/etc/beaker/snippets/per_osversion/<snippet_name>/<distro_version>`

-   `/etc/beaker/snippets/per_osmajor/<snippet_name>/<distro_major_version>`

-   `/etc/beaker/snippets/<snippet_name>`

-   `/usr/lib/python2.6/site-packages/bkr/server/snippets/<snippet_name>`

This allows administrators to customize Beaker kickstarts at whatever
level is necessary.

For example, if the system host01.example.com needs to use a network
interface other than the default, the following snippet could be placed
in `/etc/beaker/snippets/per_system/network/host01.example.com`:

    network --device eth1 --bootproto dhcp --onboot yes

Writing Kickstart Templates
---------------------------

All kickstart metadata variables are exposed as template variables. The
`system`, `distro`, `distro_tree`, `user`, and `recipe` variables are
the corresponding Beaker model objects loaded from the database. (User
templates do not have access to these model objects.)

In addition to the built-in template constructs provided by Jinja, the
following utilities are available in templates:

`end`
:   A variable which contains the string `%end` if the version of
    Anaconda requires it, otherwise undefined. For compatibility across
    all Anaconda versions, templates should always terminate sections
    with this variable. For example:

        %post
        echo "All done."
        {{ end }}

`parsed_url`
:   A Jinja filter which parses a URL using
    [`urlparse.urlparse`](http://docs.python.org/library/urlparse.html#urlparse.urlparse).

`re`
:   The Python [re](http://docs.python.org/library/re.html) module, for
    evaluating regular expressions.

`snippet`
:   A function which evaluates the named snippet and returns the result.
    If no template is found for the snippet, returns a comment to that
    effect.

`split`
:   A Jinja filter which splits on whitespace, or any other delimiter.
    See
    [`string.split`](http://docs.python.org/library/string.html#string.split).

`arch`; `osmajor`; `osversion`
:   These are Jinja tests which can be applied to `distro_tree`. Each
    takes multiple arguments, and evaluates to true if the distro tree
    matches one of the arguments. For example:

        {% if distro_tree is arch('s390', 's390x') %}
        <...>

        {% if distro_tree is osversion('RedHatEnterpriseLinux6.0') %}
        <...>

        {% if distro_tree is osmajor('RedHatEnterpriseLinux3', 'RedHatEnterpriseLinux4') %}
        <...>

`urljoin`
:   A Jinja filter which resolves a relative URL against a base URL. For
    example:

        {{ 'http://example.com/distros/'|urljoin('RHEL-6.2/') }}

    will evaluate to `http://example.com/distros/RHEL-6.2/` in the
    kickstart.

`var`
:   A function which looks up a variable by name.

Customizing Power Commands
==========================

When executing a power command (for example, rebooting a system) the
Beaker lab controller looks for an executable script named after the
system’s power type (for example, `ipmitool`). The following directories
are searched on the lab controller, in order:

-   `/etc/beaker/power-scripts`

    Custom power scripts may be placed here.

-   `/usr/lib/python2.6/site-packages/bkr/labcontroller/power-scripts`

    These templates are packaged with Beaker and should not be modified.

When a script is found it is executed with the following environment
variables set according to the system’s power settings in Beaker:

-   *power\_address*

-   *power\_id*

-   *power\_user*

-   *power\_pass*

Additionally, the power\_mode environment variable will be set to either
`on` or `off`, depending on the power action.

Integration with oVirt Engine and RHEV-M
========================================

Beaker can optionally be configured to use oVirt Engine (or the
equivalent Red Hat Enterprise Virtualization Manager product) to create
virtual machines on demand for running recipes. Version 3.0 or higher of
the product is required.

To enable oVirt integration, you must configure the API endpoint and
credentials in `/etc/beaker/server.cfg`:

    # Enable oVirt integration, for running recipes on dynamically created guests
    ovirt.enabled = True
    ovirt.api_url = 'https://manager.example.com:8443/api'
    ovirt.username = 'admin@internal'
    ovirt.password = 'example'

When oVirt integration is enabled, Beaker will attempt to create a new
virtual machine for each recipe when it is scheduled. If the oVirt
Engine is over capacity, or if creating the virtual machine fails for
any other reason, Beaker will fall back to using the regular hardware
pool for that recipe. Recipes with hardware requirements in
`<hostRequires/>` which cannot be satisfied by a virtual machine are
excluded from this process.

For Beaker’s purposes, each data center in oVirt must correspond to a
Beaker lab. The data center name should match the Beaker lab
controller’s FQDN. To meet oVirt’s naming constraints for data centers,
periods in the FQDN should be replaced with underscores and the name
truncated to 40 characters. For example, if your Beaker lab controller’s
FQDN is lab.beaker.engineering.mylocation.example.com, the corresponding
oVirt data center should be named
`lab_beaker_engineering_mylocation_exampl`. Beaker will ignore data
centers whose name does not correspond to a lab controller.

The default memory and disk size allocated to virtual machines is
controlled by the `default_guest_memory` and `default_guest_disk_size`
[settings](#configuration).

Beaker requires that autofs be enabled and configured to manage `/net` on the 
hypervisors, so that they can access installer images when starting a recipe. 
Note that this makes Red Hat Enterprise Virtualization Hypervisor (RHEV-H) 
unsuitable for running Beaker recipes, because `yum` is not available to 
install arbitrary packages. Use RHEL for the hypervisors instead.


Integration with Graphite
=========================

Beaker can optionally be configured to send metrics to the 
[Graphite](http://graphite.wikidot.com/) real-time graphing system. Beaker 
sends metrics via UDP for efficiency, and to avoid impacting the performance 
and reliability of the system, so a version of Graphite with UDP listener 
support is required.

To enable Graphite integration, configure the hostname and port of the carbon 
daemon in `/etc/beaker/server.cfg`:

    carbon.address = ('graphite.example.invalid', 2023)
    carbon.prefix = 'beaker.'

The `carbon.prefix` setting is a prefix applied to the name of all metrics 
Beaker sends to Graphite. You can adjust the prefix to fit in with your site’s 
convention for Graphite metric names, or to distinguish multiple Beaker 
environments sharing a single Graphite instance.

Aggregating metrics
-------------------

Beaker does not perform aggregation of metrics, and expects to send metrics to 
Graphite's carbon-aggregator daemon (which forwards the metrics to carbon-cache 
for storage after aggregating them). The `carbon.address` setting should 
therefore be the address of the carbon-aggregator daemon.

Beaker sends three types of metrics: counters, gauges, and durations. (A 
duration is equivalent to a gauge except that it is in seconds instead of 
arbitrary units.) The type appears at the start of the metric name, after the 
configured prefix. For example, assuming the default prefix `beaker.`, Beaker 
will periodically report the number of running recipes as 
`beaker.gauges.recipes_running`.

You should configure suitable aggregation rules for Beaker in 
`/etc/carbon/aggregation-rules.conf`. The following example assumes the default 
prefix `beaker.` and 1-minute storage resolution:

    beaker.durations.<name> (60) = avg beaker.durations.<name>
    beaker.counters.<name> (60) = sum beaker.counters.<name>
    beaker.gauges.<name> (60) = avg beaker.gauges.<name>

Useful graphs
-------------

Below are some links to useful graphs showing the overall health and 
performance of your Beaker system. These URLs could be used as the basis for 
a dashboard or given to users. The URLs assume the default metric name prefix 
`beaker.` with a Graphite instance at `graphite.example.com`.

Utilisation of all systems
  :     http://graphite.example.com/render/?width=1024&height=400
            &areaMode=stacked
            &target=beaker.gauges.systems_idle_automated.total
            &target=beaker.gauges.systems_idle_broken.total
            &target=beaker.gauges.systems_idle_manual.total
            &target=beaker.gauges.systems_manual.total
            &target=beaker.gauges.systems_recipe.total

Utilisation of shared systems
  :     http://graphite.example.com/render/?width=1024&height=400
            &areaMode=stacked
            &target=beaker.gauges.systems_idle_automated.shared
            &target=beaker.gauges.systems_idle_broken.shared
            &target=beaker.gauges.systems_idle_manual.shared
            &target=beaker.gauges.systems_manual.shared
            &target=beaker.gauges.systems_recipe.shared

Recipe queue
  :     http://graphite.example.com/render/?width=1024&height=400
            &areaMode=stacked
            &target=beaker.gauges.recipes_new
            &target=beaker.gauges.recipes_processed
            &target=beaker.gauges.recipes_queued
            &target=beaker.gauges.recipes_running
            &target=beaker.gauges.recipes_scheduled
            &target=beaker.gauges.recipes_waiting

Recipe throughput
  :     http://graphite.example.com/render/?width=1024&height=400
            &target=beaker.counters.recipes_completed
            &target=beaker.counters.recipes_cancelled
            &target=beaker.counters.recipes_aborted


Reporting from the Beaker database
==================================

Beaker's [integration with Graphite](#integration-with-graphite) can provide 
useful insights into the real-time health and performance of your Beaker 
installation. However, for reporting on historical trends you may prefer to use 
an external query/reporting tool to extract data directly from Beaker's 
database.

Beaker's source includes a number of supported reporting queries which may be 
useful for your Beaker site. They are installed with the `beaker-server` 
package under `/usr/lib/python*/site-packages/bkr/server/reporting-queries`, or 
you can [browse the queries online in Beaker's 
git](http://git.beaker-project.org/cgit/beaker/tree/Server/bkr/server/reporting-queries) 
(be sure to select the correct branch for your version of Beaker). These 
queries are "supported" in the sense that they are tested by Beaker's test 
suite, and if the queries are changed in future releases this will be called 
out in the release notes.

Beware that Beaker's database schema is subject to change in future releases, 
so if your external reporting tool uses any queries other than the supported 
ones described above then you must examine the schema upgrade instructions for 
every release and ensure the reporting tool's queries are updated as necessary.
