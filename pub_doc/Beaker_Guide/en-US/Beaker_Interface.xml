<section id="User_Guide-Getting_Started-Process-Beaker_Interface">
					<title>Beaker Interface </title>
					<section id="User_Guide-Getting_Started-Process-Beaker_Interface-Systems">
						<title>Systems</title>
							<para>
								Beaker provides an inventory of Systems(These could be a physical machine,laptop,virtual guest, or resource) attached to lab controllers. Systems can be added, removed, have details changed, and be provisioned amongst other things.
							</para>
							<section id="User_Guide-Getting_Started-Process-Beaker_Interface-Systems-System_Searching">
								<title>System Searching</title>
								<para>
									System searches are conducted by clicking on one of the items of the <application>System</application> menu at the top of the page.
								</para>
								<itemizedlist>
									<listitem>
										<para>System Searches
										<itemizedlist>
											<listitem>
												<para><application>All</application>
													<itemizedlist>
														<listitem>
															<para>Will search through all Systems listed in Beaker. </para>
														</listitem>
													</itemizedlist>
												</para>
											</listitem>
											<listitem>
												<para><application>Available</application>
													<itemizedlist>
														<listitem>
															<para>Will search through only Systems that the currently logged in user has permission to reserve.</para>
														</listitem>
													</itemizedlist>
												</para>
											</listitem>
											<listitem>
												<para><application>Free</application>
													<itemizedlist>
														<listitem>
															<para>Will search through only Systems that the currently logged in user has permission to reserve and are currently free. </para>
														</listitem>
													</itemizedlist>
												</para>
											</listitem>
										</itemizedlist>
										</para>
									</listitem>
								</itemizedlist>
								<mediaobject>
										<imageobject>
											<imagedata fileref="./images/system_menu.png" format="PNG" scalefit="1" width="444" />
										</imageobject>
										<caption><para>System Menu</para></caption>
								</mediaobject>
								<para>
									The search panel has two modes; simple and advanced. The simple search is the default, and the default search is of the System <application>Name</application>, using the <application>contains</application> operator. To toggle between the two search modes, press the <application>Toggle Search</application> link. 
								</para>
								<para>
									The first column <application>(Table)</application> is the attribute on which the search is being performed; The second <application>(Operation)</application> is the type of search, and the third <application>(Value)</application> is the actual value to search on. To add another search criteria (row), click the <application>Add(+)</application> link just below the <application>Table</application> column. When using more than just one search criteria, the defaul operation between the criterias is an SQL AND operation. The operators change depending on what type of attribute is being searched. 
								</para>
								<note>
									<title>Wildcards</title>
									<para>No operator provides explicit wildcards other than the is operation, which allows the * wildcard when searching an attribute which is a string. </para>
								</note>
								<para>
									The kind of data returned in the System search can be changed by adding/removing the result columns. To do this the <application>Toggle Result</application> Columns link is pressed and the columns checked/unchecked. 
								</para>
								<mediaobject>
									<imageobject>
										<imagedata fileref="./images/system_search_panel.png" format="PNG" scalefit="1" width="444" />
										</imageobject>
										<caption><para>Searching for a System</para></caption>
								</mediaobject>
								<note>
									<title>Shortcut for finding Systems you are using</title>
									<para>The top right hand corner has a menu which starts with Hello, followed by the name of the user currently logged in. Click on this, then down to <application>My Systems</application></para>
								</note>
							</section>
							<section id="User_Guide-Getting_Started-Process-Beaker_Interface-Systems-Adding_a_System">
                        <title>Adding a System</title>
                        <para>To add a System, go to any System search page, and click on the <application>Add(+)</application> link on the bottom left. You must be logged in to do this. After filling in the details, press the<application>Save Changes</application> button on the bottom left hand corner. </para>
                        <mediaobject>
                                 <imageobject>
                                  <imagedata fileref="./images/system_add.png" format="PNG" scalefit="1" width="444" />
                                </imageobject>
                                <caption><para>Adding a System</para></caption>
                              </mediaobject>
                        <para> You will then need to update the Power details. To test they work, try hitting the power action buttons to ensure the system is responding correctly.
                        The Arch details should then be updated, and then update the Install options with <emphasis>console=ttyS1,115200n8
                        ksdevice=link></emphasis> for each arch. See <xref linkend="User_Guide-Getting_Started-Process-Beaker_Interface-Systems-System_Details_Tabs"></xref>. You'll need to ensure that
                        your System is hooked up to the conserver.
                        Try Provisioning a machine, See <xref linkend="User_Guide-Getting_Started-Process-Tests-Provision_a_System"></xref>. You can watch the provisioning process through the
                        console. Please, be patient. The provisioning may take some time.
                        </para>
						<para> Once the System has been added, you will need to run the <emphasis>/distribution/inventory</emphasis> task (this is availble in the task repo) on the machine. See <xref linkend="User_Guide-Getting_Started-Process-Beaker_Interface-Jobs-Job_Submission-Submitting_a_New_Job"></xref> creating a new job. The XMl will probably look something like this, although substituting the distro and system name details.</para>
                        <screen>
&lt;job retention_tag="scratch"&gt;
        &lt;whiteboard&gt;
                inventory
        &lt;/whiteboard&gt;
        &lt;recipeSet priority="Normal"&gt;
                &lt;recipe kernel_options="ksdevice=link " kernel_options_post="" ks_meta="" role="RECIPE_MEMBERS" whiteboard=""&gt;
                        &lt;autopick random="false"/&gt;
                        &lt;watchdog panic="ignore"/&gt;
                        &lt;packages/&gt;
                        &lt;ks_appends/&gt;
                        &lt;repos/&gt;
                        &lt;distroRequires&gt;
                                &lt;and&gt;
                                        &lt;distro_variant op="=" value="Server"/&gt;
                                        &lt;distro_name op="=" value="RHEL6-Server-6.0"/&gt;
                                        &lt;distro_arch op="=" value="i386"/&gt;
                                        &lt;distro_virt op="=" value=""/&gt;
                                        &lt;distro_family op="=" value="RedHatEnterpriseLinux6"/&gt;
                                &lt;/and&gt;
                        &lt;/distroRequires&gt;
                        &lt;hostRequires&gt;
                                &lt;and&gt;
                                        &lt;system_type op="=" value="Machine"/&gt;
                                        &lt;hostname op="=" value="example.hostname.com"/&gt;
                                &lt;/and&gt;
                        &lt;/hostRequires&gt;
                        &lt;partitions/&gt;
                        &lt;task name="/distribution/install" role="STANDALONE"&gt;
                                &lt;params&gt;
                                        &lt;param name="PKGARGNAME" value="smolt"/&gt;
                                &lt;/params&gt;
                        &lt;/task&gt;
                        &lt;task name="/distribution/inventory" role="None"&gt;
                                &lt;params/&gt;
                        &lt;/task&gt;
                &lt;/recipe&gt;
        &lt;/recipeSet&gt;
&lt;/job&gt;
                        </screen>
                        </section>
			<section id="User_Guide-Adding_Driver_Disk">
			<title>Adding a Driver Disk</title>
			<para>Some systems may need a driver disk to be able to install certain releases.  In order to use a driver disk you need to host the driver disk under the tftp server so that it's available during netboot.  You also need to tell Beaker which families the driver disk is needed for.</para>
			<itemizedlist>
			 <listitem>
			  <para>First step is to install the driver disk on your lab controller(s).</para>
			   <itemizedlist>
			    <listitem>
			     <para>The following example assumes tftpboot is under /var/lib/tftpboot; this is true for RHEL6 and newer distros.</para>
			    </listitem>
			    <listitem>
			     <para>Make a directory to host the driver disk.
			      <screen>
# mkdir -p /var/lib/tftpboot/dd/rhel6
			      </screen>
			     </para>
			    </listitem>
			    <listitem>
			     <para>Copy the driver disk to this directory.
			      <screen>
# cp dd.img /var/lib/tftpboot/dd/rhel6
			      </screen>
			     </para>
			    </listitem>
			   </itemizedlist>
			 </listitem>
			 <listitem>
			  <para>Second step is to set the family install options for the system that needs the driver disk.</para>
			   <itemizedlist>
			    <listitem>
                             <para>If you don't have any arch specific install options you need to create one first. Install options are inherited in the order of Arch, Family, and Update.</para>
                              <mediaobject>
                               <imageobject>
                                <imagedata fileref="./images/initrd-driverdisk1.png" format="PNG" scalefit="1" width="444" />
                               </imageobject>
                               <caption><para>Adding a blank install option for arch.</para></caption>
                              </mediaobject>
			    </listitem>
			    <listitem>
                             <para>Once you have an arch specific entry you can create a family specific entry.  The image below shows adding the driver disk we created for RHEL6. Notice that the path is from the chroot of the tftpserver, not /var/lib/tftpboot/.</para>
                              <mediaobject>
                               <imageobject>
                                <imagedata fileref="./images/initrd-driverdisk2.png" format="PNG" scalefit="1" width="444" />
                               </imageobject>
                               <caption><para>Adding a driver disk entry for RHEL6.</para></caption>
                              </mediaobject>
			    </listitem>
			   </itemizedlist>
			 </listitem>
			</itemizedlist>
                        </section>

                        <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Systems-System_Details_Tabs">
                        <title> System Details Tabs</title>
                        <para>After finding a System in the search page, clicking on the System name will show the System details. To change these details, you must be logged in as either the owner of the System, or an admin. </para>
                          <itemizedlist>
                            <listitem>
                              <para><application>System Details</application>
                                <orderedlist>
                                  <listitem>
                                    <para><application>System Name</application>: Unique hostname that identifies the machine, also referred to as fqdn (fully qualified domain name).
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para><application>Date Checkin</application>: When the machine was added to the inventory.
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para><application>Last Checkin</application>: Last time this machine had its inventory updated
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para><application>Lender</application>: Name of the organisation that has lent this system to beaker's inventory.
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para><application>Serial Number</application>: Serial Number of the machine.
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para><application>Condition</application>: This can be one of the following:
                                    <itemizedlist>
                                        <listitem>
                                          <para><application>Automated</application>: In a working state, can have jobs run against it.
                                          </para>
                                        </listitem>
                                        <listitem>
                                          <para><application>Manual</application>: In a working state, can not have jobs run against it (designed so people can test machine without having other people's jobs run on it).
                                          </para>
                                        </listitem>
                                        <listitem>
                                          <para><application>Broken</application>: Not in a working state and not available to have jobs run on it.
                                          </para>
                                        </listitem>
                                        <listitem>
                                          <para><application>Removed</application>: System no longer exists in the inventory.
                                          </para>
                                        </listitem>
                                      </itemizedlist>
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para><application>Shared</application>: Allows others to run jobs against this machine.
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para><application>Secret</application>: Stops other people from seeing this system in the inventory.
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para><application>Lab Controller</application>: The Lab controller to which it is connected.
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para><application>Type</application>: This can be one of the following: 
                                    <itemizedlist>
                                       <listitem>
                                          <para><application>Machine</application>: A physical machine that does not fit the other categories.
                                          </para>
                                        </listitem>
                                        <listitem>
                                          <para><application>Laptop</application>: A laptop.
                                          </para>
                                        </listitem>
                                        <listitem>
                                          <para><application>Virtual</application>: A virtual machine, this is just a placeholder that has a hostname and MAC address that corresponds to a DHCP record.
                                          </para>
                                        </listitem>
                                        <listitem>
                                          <para><application>Resource</application>: Something which is not a computer. i.e a monitor.
                                          </para>
                                        </listitem>
                                        <listitem>
                                          <para><application>Prototype</application>: New piece of hardware.
                                          </para>
                                        </listitem>
                                      </itemizedlist>
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para><application>Last Modification</application>: The last time the system details were changed.
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para><application>Vendor</application>: The brand.
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para><application>Model</application>: The model designation.
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para><application>Location</application>: The physical location. 
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para><application>Owner</application>: The user who currently owns this machine (by default it is the user who added the entry to inventiry, but owners can be reassigned)
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para><application>Loaned To</application>: The current Loanee. If this field is non empty, the system is only able to be used by the loanee.
                                    </para>
                                  </listitem>
                                   <listitem>
                                    <para><application>MAC Address</application>: The MAC address of the network device.
                                    </para>
                                  </listitem>
                                </orderedlist>
                              </para>
                              </listitem>
                            </itemizedlist>
                        </section>
                        <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Systems-System_Activity">
                        <title>System Activity</title>
                        <para>To search through the historical activity of all Systems, navigate to <application>Activity>&gt;Systems</application> at the top of the page. The default search is <application>contains</application> on the <application>Property</application> attribute. </para>
                        <note>
                          <title>Individual System history
                          </title>
                          <para>To search the history of a specific System, see the<application>History tab</application>  in Section 5.1.3, System Details Tab</para>
                        </note>
                        </section>
                        <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Distros">
                          <title>Distros</title>
                            <para>Beaker can keep a record of Distros that are available to install on Systems in its Inventory. </para>
                              <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Distros-Distro_Searching">
                                <title>Distro Searching</title>
                                <para>The find a particular Distro, click <application>Distros&gt;All</application>. The default search is on the Distro's <application>Name</application>, with a <application>contains</application> clause </para>
                              </section>

                            <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Distros-Distro_Activity">
                              <title>Distro Activity</title>
                              <para>To search through the historical activity of all Distros, navigate to <application>Activity&gt;Distros</application> at the top of the page. The default search is <application>contains</application> on the <application>Property</application> attribute. </para>
                            </section>
                         </section>
                         <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Jobs">
                         <title>Jobs</title>
                          <para>
                            The purpose of a Job is to provide an encapsulation of Tasks. It is to provide a single point of submission of these Tasks, and a single point of reviewing the output and results of these Tasks. The Tasks within a Job may or may not be related to each other; although it would make sense to define Jobs based on the relationship of the Tasks within it. Once a Job has been submitted you can not alter its contents, or pause it. You can however cancel it (Section 5.3.3.4, “Job Results”), and alter its Recipe Set's priorities (you can only lower the priority level if you are not in the admin group). Adjusting this priority upwards will change which Recipe Set is run sooner, and vice a versa. 
                          </para>
                          <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Jobs-Job_Workflow">
                          <title>Job Workflow</title>
                            <para>To create a simple Job workflow, see the <application>bkr workflow-simpl</application> command in Chapter 2, Beaker client</para>
                          </section>
                          <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Jobs-Job_Searching">
                            <title>Job Searching</title>
                            <para>To search for a Job, navigate to <application>Scheduler&gt;Jobs</application> at the top of the page. To look up the <application>Job ID</application>, enter a number in the search box and press the <application>Lookup ID button</application>. Please see Section 5.1.1, “System Searching” for details on searching. </para>
                            <note>
                              <title>Quick Searches</title>
                              <para>By pressing the <application>Running,Queued</application>, or <application>Completed</application>  buttons you can quickly display Recipes that have a status of running,queued, and completed respectively. </para>
                            </note>
                          </section>
                          <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Jobs-Job_Submission">
                            <title>Job Submission</title>
                              <para>There are two ways of submitting a Job through the web app.They are outlined below. </para>
                                <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Jobs-Job_Submission-Submitting_a_New_Job">
                                  <title>Submitting a New Job</title>
                                    <para>Once you have created an XML Job workflow, you are able to submit it as a new Job. To do this, go to the<application>Scheduler &gt; New Job</application>. Click <application>Browse</application> to select your XML file, and then hit the<application> Submit Data</application> button. The next page shown gives you an opportunity to check/edit your XML before queueing it as a Job by pressing the <application>Queue </application>button.
                                    </para>
                                </section>
                                <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Jobs-Job_Submission-Cloning_an_Existing_Job">
                                  <title>Cloning an existing Job</title>
                                    <para>Cloning a Job means to take a Job that has already been run on the System, and re-submit it. To do this you first need to be on the Job search page. See Section 5.3.2, “Job Searching”. </para>
                                      <mediaobject>
                                        <imageobject>
                                          <imagedata fileref="./images/job_submit_clone.png" format="PNG" scalefit="1" width="444" />
                                       </imageobject>
                                        <caption>Cloning a Job</caption>
                                      </mediaobject>
                                  <para>Clicking on <application>Clone</application> under the Action column will take you to a page that shows the structure of the Job in the XML. </para>
                                  <note>
                                    <title>Submitting a slightly different Job</title>
                                      <para>If you want to submit a Job that's very similar to a Job already in Beaker,you can use the Clone button to change details of a previous Job and resubmit it!</para>
                                  </note>
                                </section>
                                <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Jobs-Job_Submission-Job_workflow_details">
                                  <title>Job workflow details</title>
                                    <para>There are various XML entities in the job definitions created for a workflow. Each job has a root node called the <application>job</application> element:
                                      <screen>&lt;job&gt;
&lt;/job&gt;
                                      </screen>
                                    </para>
                                    <para>A direct child is the <application>whiteboard</application>. The content is normally a mnemonic piece of text describing the job: </para>
                                    <screen>&lt;job&gt;
&lt;whiteboard&gt;
        Apache 2.2 test
&lt;/whiteboard&gt;
&lt;/ob&gt;
</screen>
                                    <para>The next element is the <application>recipeSet</application> (which describes a recipe set. See <xref linkend="User_Guide-Getting_Started-Process-Beaker_Interface-Recipes"></xref> for full details). A job workflow can have one or more of these elements, which contain one or more <application>recipe</application> elements. Whereas tasks within a recipe are run in sequence on a single system, all recipes within a recipe set are run simultaneously on systems controlled by a common lab controller. This makes recipe sets useful for scheduling multihost jobs, where recipes playing different roles (e.g. client, server) run concurrently on separate systems.</para>
                                    <para>When multiple recipe sets are defined in a single job, they are run in no predetermined order, are not necessarily scheduled concurrently and may run on systems controlled by different lab controllers. The advantage of combining them into one job is that they will report a single overall result (as well as a result for each recipe set) and can be managed (e.g. submitted, cancelled) as a single unit.</para>
                                   <screen>&lt;job&gt;
  &lt;whiteboard&gt;
    Apache 2.2 test
  &lt;/whiteboard&gt;
    &lt;recipeset&gt;
    &lt;/recipeset&gt;
&lt;/job&gt;
</screen>
                                    <para>As noted above, the <application>recipeSet</application> element contains <application>recipe</application> elements. Individual recipes can have the following attributes
                                      <itemizedlist>
                                        <listitem>
                                          <para>
                                            <application>kernel_options</application>
                                            <itemizedlist>
                                             <listitem>
                                              <para><application>vnc</application> Setting this will do a vnc install</para>
                                             </listitem>
                                            </itemizedlist>
                                          </para>
                                        </listitem>
                                        <listitem>
                                          <para>
                                            <application>kernel_options_post</application>
                                          </para>
                                        </listitem>
                                        <listitem>
                                          <para>
                                            <application>ks_meta</application>
                                            <itemizedlist>
                                             <listitem>
                                              <para><application>manual</application> minimal kickstart, should also use mode=vnc</para>
                                             </listitem>
                                             <listitem>
                                              <para><application>mode=text|cmdline|graphical|vnc</application> Specify what mode to use for install, default is either text or cmdline</para>
                                             </listitem>
                                             <listitem>
                                              <para><application>firewall=port:protocol&lt;,port:protocol&gt;</application> Default is firewall disabled, Example: firewall=imap:tcp,1234:ucp,47 </para>
                                             </listitem>
                                             <listitem>
                                              <para><application>keyboard=us</application> Specify Keyboard, Default is us</para>
                                             </listitem>
                                             <listitem>
                                              <para><application>lang=en_US.UTF-8</application> Specify install language, Default is en_US.UTF-8</para>
                                             </listitem>
                                             <listitem>
                                              <para><application>password=&lt;encrypted&gt;</application> Override default password value, must be encrypted</para>
                                             </listitem>
                                             <listitem>
                                              <para><application>selinux=--enforcing</application> Selinux is enabled by default, --disabled or --permissive are valid choices</para>
                                             </listitem>
                                             <listitem>
                                              <para><application>timezone=America/New_York</application> TimeZone to use, default to America/New_York</para>
                                             </listitem>
                                             <listitem>
                                              <para><application>scsidevices=qla2xxx,megaraid_mbox</application> Only load these scsi modules if set</para>
                                             </listitem>
                                             <listitem>
                                              <para><application>ethdevices=tg3,e1000</application> Only load these network modules if set</para>
                                             </listitem>
                                             <listitem>
                                              <para><application>no_TYPE_repos</application> If this option is specified it will omit repos of TYPE from the kickstart, TYPE can be one of debug, optional, adddon or variant.  You can see the different types of repos available for a distro on the /distrotrees page under the repo tab.</para>
                                             </listitem>
                                             <listitem>
                                              <para><application>skipx</application> Do the install without setting up graphics.  This is needed for headless systems.</para>
                                             </listitem>
                                             <listitem>
                                              <para><application>ignoredisk</application> Use this to ignore certain disks for install.  For example: ignoredisk=--only-use=sda </para>
                                             </listitem>
                                             <listitem>
                                              <para><application>rootfstype</application> Specifies root filesystem type</para>
                                             </listitem>
                                            </itemizedlist>
                                          </para>
                                        </listitem>
                                        <listitem>
                                          <para>
                                            <application>role</application> In a Multihost environment, it could be either <application>SERVERS</application>, <application>CLIENT</application> or <application>STANDALONE</application>. If it is not important, it can be <application>None</application>. 
                                          </para>
                                        </listitem>
                                        <listitem>
                                          <para>
                                            <application>whiteboard</application>Text that describes the Recipe 
                                          </para>
                                        </listitem>
                                      </itemizedlist>
                                    </para>
                                    <para>Here is an example:
                                    <screen>&lt;job&gt;
  &lt;whiteboard&gt;
    Apache 2.2 test
  &lt;/whiteboard&gt;
    &lt;recipeset&gt;
      &lt;recipe kernel_options="" kernel_options_post="" ks_meta="" role="None" whiteboard="Lab Controller"&gt;
      &lt;/recipe&gt;
    &lt;/recipeset&gt;
&lt;/job&gt;
 </screen>
                                   </para>
                                  <note>
                                    <title>Avoid having many recipes in one recipe set</title>
                                      <para>Because recipes within a recipe set are required to run simultaneously, no recipe will commence execution until all other sibling recipes are ready. This involves each recipe reserving a system, and waiting until every other recipe has also reserved a system. This can tie up resources and keep them idle for long amounts of time. It is thus worth limiting the recipes in each recipeset to only those that actually need to run simultaneously (i.e multihost jobs)</para>
                                  </note>
                                  <para>Within the <application>recipe</application> element, you can specify what packages need to be installed on top of anything that comes installed by default. </para>
                                  <screen>&lt;job&gt;
  &lt;whiteboard&gt;
    Apache 2.2 test
  &lt;/whiteboard&gt;
    &lt;recipeSet&gt;
      &lt;recipe kernel_options="" kernel_options_post="" ks_meta="" role="None" whiteboard="Lab Controller"&gt;
        &lt;packages&gt;
          &lt;package name="emacs"/&gt;
          &lt;package name="vim-enhanced"/&gt;
          &lt;package name="unifdef"/&gt;
          &lt;package name="mysql-server"/&gt;
          &lt;package name="MySQL-python"/&gt;
          &lt;package name="python-twill"/&gt;
                        &lt;/packages&gt;
      &lt;/recipe&gt;
    &lt;/recipeSet&gt;
&lt;/job&gt;
 </screen>
                                  <para>If you would like you can also specify your own repository that provides extra packages that your job requires. Use the <application>repo</application>  tag for this. You can use any text you like for the name attribute. </para>
                                  <screen>&lt;job&gt;
 &lt;whiteboard&gt;
    Apache 2.2 test
  &lt;/whiteboard&gt;
    &lt;recipeSet&gt;
      &lt;recipe kernel_options="" kernel_options_post="" ks_meta="" role="None" whiteboard="Lab Controller"&gt;
        &lt;packages&gt;
         &lt;package name="emacs"/&gt;
          &lt;package name="vim-enhanced"/&gt;
          &lt;package name="unifdef"/&gt;
          &lt;package name="mysql-server"/&gt;
          &lt;package name="MySQL-python"/&gt;
          &lt;package name="python-twill"/&gt;
        &lt;/packages&gt;

        &lt;repos&gt;
          &lt;repo name="myrepo_1" url="http://my-repo.com/tools/beaker/devel/"/&gt;
        &lt;/repos&gt;

      &lt;/recipe&gt;
    &lt;/recipeSet&gt;
&lt;/job&gt;
     </screen>
                                <para>To actually determine what distro will be installed, the <application>distroRequires</application> element needs to be populated. Within, we can specify such elements as<application> distro_arch, distro_name</application> and <application>distro_method</application>. This relates to the Distro architecture, the name of the Distro, and it's install method (i.e nfs,ftp etc) respectively. The <application>op</application> determines if we do or do not want this value i.e = means we do want that value, != means we do not want that value. The <application>distro_virt</application> element will determine whether we install on a virtual machine or not. </para>
                                <screen>&lt;job&gt;
  &lt;whiteboard&gt;
    Apache 2.2 test
  &lt;/whiteboard&gt;
    &lt;recipeSet&gt;
      &lt;recipe kernel_options="" kernel_options_post="" ks_meta="" role="None" whiteboard="Lab Controller"&gt;
        &lt;packages&gt;
          &lt;package name="emacs"/&gt;
          &lt;package name="vim-enhanced"/&gt;
          &lt;package name="unifdef"/&gt;
          &lt;package name="mysql-server"/&gt;
          &lt;package name="MySQL-python"/&gt;
          &lt;package name="python-twill"/&gt;
        &lt;/packages&gt;

        &lt;repos&gt;
          &lt;repo name="myrepo_1" url="http://my-repo.com/tools/beaker/devel/"/&gt;
        &lt;/repos&gt;
        &lt;distroRequires&gt;
          &lt;and&gt;
            &lt;distro_arch op="=" value="x86_64"/&gt;
            &lt;distro_name op="=" value="RHEL5-Server-U4"/&gt;
            &lt;distro_method op="=" value="nfs"/&gt;
          &lt;/and&gt;
          &lt;distro_virt op="=" value=""/&gt;
        &lt;/distroRequires&gt;
      &lt;/recipe&gt;
    &lt;/recipeSet&gt;
&lt;/job&gt;
 </screen>
                                <para><application>hostRequires</application> has similar attributes to <application>distroRequires</application></para>
                                <screen>&lt;job&gt;
  &lt;whiteboard&gt;
    Apache 2.2 test
  &lt;/whiteboard&gt;
    &lt;recipeSet&gt;
      &lt;recipe kernel_options="" kernel_options_post="" ks_meta="" role="None" whiteboard="Lab Controller"&gt;
        &lt;packages&gt;
           &lt;package name="emacs"/&gt;
          &lt;package name="vim-enhanced"/&gt;
          &lt;package name="unifdef"/&gt;
          &lt;package name="mysql-server"/&gt;
          &lt;package name="MySQL-python"/&gt;
          &lt;package name="python-twill"/&gt;
        &lt;/packages&gt;
        &lt;repos&gt;
          &lt;repo name="myrepo_1" url="http://my-repo.com/tools/beaker/devel/"/&gt;
        &lt;/repos&gt;
        &lt;distroRequires&gt;
          &lt;and&gt;

            &lt;distro_arch op="=" value="x86_64"/&gt;
            &lt;distro_name op="=" value="RHEL5-Server-U4"/&gt;
            &lt;distro_method op="=" value="nfs"/&gt;
          &lt;/and&gt;
          &lt;distro_virt op="=" value=""/&gt;
        &lt;/distroRequires&gt;
        &lt;hostRequires&gt;
          &lt;and&gt;
            &lt;arch op="=" value="x86_64"/&gt;
            &lt;hypervisor op="=" value=""/&gt;
          &lt;/and&gt;
        &lt;/hostRequires&gt;
      &lt;/recipe&gt;
    &lt;/recipeSet&gt;
&lt;/job&gt;
 </screen>
 <note>
   <title>Bare metal vs hypervisor guests</title>
   <para>
     Beaker supports direct provisioning of hypervisor guests.
     These hypervisor guests live on non volatile machines, and can be 
     provisioned as a regular bare metal system would. They look the same as 
     regular system entries, except their <varname>Hypervisor</varname> 
     attribute is set. If your recipe requires a bare metal machine, be sure 
     to include &lt;hypervisor op="=" value=""/&gt; in your 
     &lt;hostRequires/&gt;
   </para>
 </note>
                             <para>All that's left to populate our XML with, are the<application> task </application> elements. The two attributes we need to specify are the <application>name</application> and the <application>role</application>. Details of how to find which Task's are available, see Section 5.5.2, “Task Searching”. Also note that we've added in a <application>param</application> as a descendant of <application>task</application>. The <application>value</application> of this will be assigned to a new environment variable specified by<application> name.</application>
                             </para>
                            <screen>&lt;job&gt;
  &lt;whiteboard&gt;
    Apache 2.2 test
  &lt;/whiteboard&gt;
    &lt;recipeSet&gt;
      &lt;recipe kernel_options="" kernel_options_post="" ks_meta="" role="None" whiteboard="Lab Controller"&gt;
        &lt;packages&gt;
          &lt;package name="emacs"/&gt;
          &lt;package name="vim-enhanced"/&gt;
          &lt;package name="unifdef"/&gt;
          &lt;package name="mysql-server"/&gt;
          &lt;package name="MySQL-python"/&gt;
          &lt;package name="python-twill"/&gt;
        &lt;/packages&gt;

        &lt;repos&gt;
          &lt;repo name="myrepo_1" url="http://my-repo.com/tools/beaker/devel/"/&gt;
        &lt;/repos&gt;
        &lt;distroRequires&gt;
          &lt;and&gt;
            &lt;distro_arch op="=" value="x86_64"/&gt;
            &lt;distro_name op="=" value="RHEL5-Server-U4"/&gt;
            &lt;distro_method op="=" value="nfs"/&gt;
          &lt;/and&gt;
          &lt;distro_virt op="=" value=""/&gt;
        &lt;/distroRequires&gt;

        &lt;task name="/distribution/install" role="STANDALONE"&gt;
          &lt;params&gt;
                &lt;param name="My_ENV_VAR" value="foo"/&gt;
           &lt;/params&gt;
         &lt;/task&gt;

      &lt;/recipe&gt;
    &lt;/recipeSet&gt;
&lt;/job&gt;
                               </screen>
                               <para>
                                 By default, the kickstart fed to Anaconda is a generalised 
                                 kickstart for a specific distro major version. However, there are a couple of ways 
                                 to pass in a customized kickstart.
                               </para>
                               <para>
                                 One method is to pass the <code>ks</code> key/value 
                                 to the <code>kernel_options</code> parameter of the <code>recipe</code> element.
                                 Using this method the kickstart will be used by Anaconda unaltered.
                                 <screen>
&lt;recipe kernel_options='ks=http://example.com/ks.cfg' /&gt;
                                 </screen>
                                </para>
                                 <para>
                                   Alternatively, the kickstart can be written out within the <code>recipe</code> element.
                               <screen>

&lt;kickstart&gt;
  install
  key --skip
  lang en_US.UTF-8
  skipx
  keyboard us
  network --device eth0 --bootproto dhcp
  rootpw --plaintext testingpassword
  firewall --disabled
  authconfig --enableshadow --enablemd5
  selinux --permissive
  timezone --utc Europe/Prague

  bootloader --location=mbr --driveorder=sda,sdb
# Clear the Master Boot Record
  zerombr
# Partition clearing information
  clearpart --all --initlabel
# Disk partitioning information
  part /RHTSspareLUN1 --fstype=ext3 --size=20480 --asprimary --label=sda_20GB --ondisk=sda
  part /RHTSspareLUN2 --fstype=ext3 --size=1 --grow --asprimary --label=sda_rest --ondisk=sda
  part /boot --fstype=ext3 --size=200 --asprimary --label=BOOT --ondisk=sdb
# part swap --fstype=swap --size=512  --asprimary --label=SWAP_007 --ondisk=sdb
  part / --fstype=ext3 --size=1 --grow --asprimary --label=ROOT  --ondisk=sdb

  reboot

  %packages --excludedocs --ignoremissing --nobase
&lt;/kickstart&gt;
                               </screen>
                               </para>
                               <para>
                                 When passed a custom kickstart in this manner, Beaker will add
                                 extra entries into the kickstart.
                                 These will come from install options that have been specified for that
                                 system, arch and distro combination;
                                 partitions, packages and repos that have been specified
                                 in the <code>recipe</code> element; the relevant 
                                 snippets needed for running the harness. For further information on how Beaker processes
                                 kickstarts and how to utilize their templating language, see
                                 <xref linkend="Administration-Customizing_Kickstarts" />.
                               </para>

</section>
                         <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Jobs-Job_Submission-Job_Results">
                            <title>Job Results</title>
                            <para>The whole purpose of Jobs is to view the output of the Job, and more to the point, Tasks that ran within the Job. To do this, you must first go to the Job search screen (Section 5.3.2, “Job Searching”). After finding the Job you want to see the results of, click on the link in the  <application>ID</application> column.You don't have to wait until the Job has completed to view the results. Of course only the results of those Tasks that have already finished running will be available. 
                            </para>
                            <para>The Job results page is divided by<application> Recipe Set</application>. To show the results of each Recipe within these Recipe Sets, click the <application>Show All Results</application>  button. You can just show the tasks that have a status of <application>Fail</application> by clicking <application>Show Failed Results</application>.
                            </para>
                            <para>While your Job is still <application>Queued</application> it's possible to change the priority. You can change the priority of individual Recipe Sets by changing the value of <application>Priority</application>, or you can change all the Job's Recipe Sets at once by clicking an option beside the text <application>Set all RecipeSet priorities</application>, which is at the top right of the page. If successful, a green success message will briefly display, otherwise a red error message will be shown. 
                            </para>
                            <note>
                              <title>Priority permissions</title>
                              <para>If you are not an Admin you will only be able to lower the priority. Admins can lower and raise the priority </para>
                            </note>
                            <mediaobject>
                              <imageobject>
                                      <imagedata fileref="./images/job_priority_change.png" format="PNG" scalefit="1" width="444" />
                                   </imageobject>
                                   <caption>Changing the priority of a Job's Recipe Set</caption>
                                </mediaobject>
                                <para><application>Result Details</application>
                                  <itemizedlist>
                                    <listitem>
                                      <para><application>Run</application>
                                        <itemizedlist>
                                          <listitem>
                                            <para>This is the <application>ID</application> of the instance of the particular Task.</para>
                                          </listitem>
                                          </itemizedlist>
                                        </para>
                                      </listitem>
                                      <listitem>
                                        <para><application>Task</application>
                                          <itemizedlist>
                                            <listitem>
                                              <para>A Task which is part of our current Job. </para>
                                          </listitem>
                                        </itemizedlist>
                                        </para>
                                      </listitem>
                                          <listitem>
                                      <para><application>Start</application>
                                        <itemizedlist>
                                          <listitem>
                                            <para>The time at which the Task commenced. </para>
                                          </listitem>
                                           </itemizedlist>
                                        </para>
                                      </listitem>
                                          <listitem>
                                      <para><application>Finish</application>
                                        <itemizedlist>
                                          <listitem>
                                            <para>The time at which the Task completed. </para>
                                          </listitem>
                                           </itemizedlist>
                                        </para>
                                      </listitem>
                                          <listitem>
                                      <para><application>Duration</application>
                                        <itemizedlist>
                                          <listitem>
                                            <para>Time the Task took to run. </para>
                                          </listitem>
                                           </itemizedlist>
                                        </para>
                                      </listitem>
                                           <listitem>
                                      <para><application>Logs</application>
                                        <itemizedlist>
                                          <listitem>
                                            <para>This is a listing of all the output logs generated during the running of this Task. </para>
                                          </listitem>
                                           </itemizedlist>
                                        </para>
                                      </listitem>
                                          <listitem>
                                      <para><application>Status</application>
                                        <itemizedlist>
                                          <listitem>
                                            <para>This is the current Status of the Task. <application>Aborted</application>,<application>Cancelled</application> and <application>Completed</application> mean that the Task has finished running. </para>
                                          </listitem>
                                           </itemizedlist>
                                        </para>
                                      </listitem>
                                      <listitem>
                                      <para><application>Action</application>
                                        <itemizedlist>
                                          <listitem>
                                            <para>The two options here are Cancel and Clone.See Section 5.3.3.2, “Cloning an existing Job” to learn about Cloning.</para>
                                          </listitem>
                                           </itemizedlist>
                                        </para>
                                      </listitem>
                                      </itemizedlist>
                                      </para>
                                      <note>
                                        <title>Viewing Job results at a glance
                                        </title>
                                          <para>If you would to be able to look at the Result  of all Tasks within a particular Job, try the Matrix Report, See Section 5.6.1, “Matrix Report”. 
                                          </para>
                                      </note>
                            </section>
                        </section>
                      </section>
                    </section>
                    <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Recipes">
                      <title>Recipes</title>
                        <para>Recipes are contained within a Job (although indirectly, as directly they are contained in a <application>Recipe Set</application>) and are themselves a container for Tasks. There can be more than one Recipe per Job. The purpose of a Recipe is to group a set of Tasks into a single logical unit. </para>
                        <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Recipes-Recipe_Searching">
                          <title>Recipe Searching</title>
                            <para>The Recipe search is accessed through the <application>Scheduler</application>  at the top of the page, and clicking on the <application>Recipe</application> link. </para>
                            <mediaobject>
                              <imageobject>
                                      <imagedata fileref="./images/recipe_search.png" format="PNG" scalefit="1" width="444" />
                                   </imageobject>
                                   <caption>Searching for a Recipe</caption>
                                </mediaobject>
                          <para>To look up the <application>Recipe ID</application> enter a number into the search box and press the <application>Lookup ID</application>  button. See Section 5.1.1, “System Searching” for details on searching. </para>
                          <note>
                            <title>Quick Searches</title>
                              <para>By pressing the <application>Running</application>,<application>Queued</application>, or <application>Completed</application> buttons you can quickly display Recipes that have a status of running,queued, and completed respectively. </para>
                          </note>
                        </section>
                        <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Recipes-Recipe_Action">
                          <title>Recipe Actions</title>
                            <para>At any time you may wish to cancel the Recipe, you may press the <application>Cancel</application> link that is placed under the <application>Action</application> column. </para>
                        </section>
                    </section>
                    <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Tasks">
                      <title>Tasks</title>
                        <para>Tasks are the lowest unit in the Job hierarchy, and running a Task is the primary purpose of running a Job. There purpose is to run one or more commands, and then collect the results of those commands in a way that other entities can access them. You can run as many or as few Tasks in a Job as you like. </para>
                        <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Tasks-Creating_a_Task">
                          <title>Creating a Task</title>
                            <para>To create Tasks the <application>rhts-devel</application> package will need to be installed. From your terminal, type: </para>
                            <screen>$ yum install rhts-devel</screen>
                            <para>Now make a new directory from where you will create the test. Then <application>cd</application> into the newly created folder and run the following: </para>
                            <screen>$ rhts-create-new-test
$ ls -l
Makefile  PURPOSE  runtest.sh
                            </screen>
                            <para>Below is a rundown of the files created and how to use them </para>
                            <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Tasks-Creating_a_Task-runtest_sh">
                              <title>runtest.sh</title>
                                <para>
                              The core of each Beaker test is a <application>runtest.sh</application>  shell script. It performs the testing (or delegates the work by invoking another script or executable) and reports the results. Either write the code that performs the test in the <application>runtest.sh</application> shell script or have runtest.sh execute another program that does the bulk of the work in perhaps another language. Choose a language appropriate to the job (and with which you are familiar): testing of a library could be written in C, parsing of text streams could be done in Perl, and GUI scripting in Python. Languages can be mixed and matched as appropriate within a single test - the <application>runtest.sh</application> script can call other code as necessary. Aim for correctness and readability: remember that others may have to debug this code if a test is flawed. Here is the example<application> runtest.sh</application>: 
                              </para>
                              <screen>#!/bin/sh
# Copyright (c) 2006  All rights reserved. This copyrighted
# material  is made available to anyone wishing to use, modify, copy, or
# redistribute it subject to the terms and conditions of the GNU General
# Public License v.2.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation, Inc., 
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,USA.

# Author: Your Name &lt;Your Email&gt;</screen>
                              <para>
                                The do-my-test.sh is a rather simple test, seen below, just enough to illustrate the required components of a task. 
                              </para>
                              <screen>#!/bin/sh
# simple test example

ls -al /root/.ssh</screen>
                              <para>
                                The exit code from listing the contents of<application> /root/.ssh</application>  will be saved to the <application>$?</application> system variable and based on this,<application> rhts-run-simple-test </application>will report the failure or success of the Task. So the most basic Beaker coding requirements are that a shell script must be sourced <application>(rhts-environment.sh)</application> and the report_result API must be called (this is called in <application>rhts-run-simple-test</application>).The output was sent to <application>$OUTPUTFILE </application>(in <application>rhts-environment.sh</application>). The Beaker API provides the <application>$OUTPUTFILE</application> variable so each test can create a log file to record its activities. When run from the command line, <application>$OUTPUTFILE</application> points to a temporary file in<application> /tmp</application>. When run in a test lab environment, the logs are stored in a central location. The report_result method is always called to inform the Beaker API of the success or failure of the test. 
                              </para>
                            </section>
                            <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Tasks-Creating_a_Task-Makefile">
                              <title>Makefile </title>
                              <para>A standard Beaker Makefile coordinates many aspects of developing and running a Beaker test: 
                                <itemizedlist>
                                  <listitem>
                                    <para>compiling test executables. 
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para>packaging test files into a single RPM. 
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para>downloading external source files for use in the test. 
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para>collect test files into a known location for execution. 
                                    </para>
                                  </listitem>
                                  <listitem>
                                    <para>running tests 
                                    </para>
                                  </listitem>
                                </itemizedlist>
                              </para>
                              <para>
                              A sample Makefile is copied into the local directory when rhts-create-new-test tool is invoked (or can be found a<application>t /usr/share/doc/rhts-devel-2.6/Makefile.template</application>). The Makefile sets up certain targets and defines variables necessary for test execution and reporting. It is best to use this example when writing a new test, copying and modifying it as necessary. So for example, in order to have an executable compiled by the Makefile, the following two lines were changed. 
                              </para>
                              <screen>
                    BUILT_FILES=do-my-test
                    FILES=$(METADATA) runtest.sh Makefile PURPOSE do-my-test.c
                              </screen>
                              <para>
                              When <application>make run</application> is typed, the Makefile will compile<application> do-my-test.cintodo-my-test</application>  and run runtest.sh, which will then execute <application>do-my-test</application>. You do not have to enter anything in the <application>BUILT_FILES</application>  directive if you are not compiling an executable. Also be sure to fill in the following section: 
                              </para>
                              <screen># The toplevel namespace within which the test lives.
# FIXME: You will need to change this:
TOPLEVEL_NAMESPACE=

# The name of the package under test:
# FIXME: you wil need to change this:
PACKAGE_NAME=

# The path of the test below the package:
# FIXME: you wil need to change this:
RELATIVE_PATH=</screen>
                              <para>
                              Those three place holders will be used to determine how your Task is named in Beaker, and also how it's mounted on a test System. It will be called /<application>TOPLEVEL_NAMESPACE/PACKAGE_NAME/RELATIVE_PATH</application> and it will be mounted the same in the <application>/mnt/tests</application> directory on a test System. 
                              </para>
                            </section>
                            <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Tasks-Creating_a_Task-Purpose">
                              <title>PURPOSE</title>
                                <para>The test code directory contains a plain text file called<application>PURPOSE</application> which explains what the test addresses along with any other information useful for troubleshooting or understanding it better. The <application>PURPOSE</application> file has no minimum or maximum length but should provide useful information. For example:  </para>
                                <screen>$ cat PURPOSE
This trivial test compiles a .c file, runs the resulting code, and checks
that the output is as expected.

It is intended as a simple example of how to write a test that
compiles source code to a binary and reports a single result
using rhts-run-simple-test

It can also be used as a primitive smoketest for the compiler.</screen>
                            </section>
                            <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Tasks-Creating_a_Task-Packaging">
                            <title>Packaging</title>
                              <para>Before we can add a new Task to Beaker we need to package it. Firstly, you're able to run the task locally (if it makes sense) to ensure that the task operates as expected. If you would like to run the task locally: </para>
                              <screen>
<application>$ make run</application>
chmod a+x ./runtest.sh
./runtest.sh
/tmp/simple_test/do-my-test.sh
Running ./do-my-test.sh  As root: 
total 48
drwx------  2 root root  4096 Dec 15 08:41 .
drwxr-x--- 24 root root 12288 Jun  2 14:57 ..
-rw-------  1 root root   415 Dec 13 19:12 authorized_keys
-rw-r--r--  1 root root  8630 May 25 09:42 known_hosts
...finished running ./do-my-test.sh, exit code=0
/// result: PASS
   Log: /tmp/tmp.c24401</screen>
                              <para>Once you're happy it works as expected, you can run the following: </para>
                              <note>
                                <title>Tagging</title>
                                <para>
                                If you wish to, and your Task is revisioned with git or CVS, you can increase the version of the package with the following command: 
                                </para>
                                <para>$ make tag</para>
                              </note>
                            </section>
                        </section>
                        <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Tasks-Task_Searching">
                        <title>Task Searching</title>
                        <para>To search for a Task, go to <application>Scheduler>Task</application> Library at the top of the page. The default search is on the <application>Name</application>  property, with the <application>contains</application> operator. See Section 5.1.1, “System Searching” for search details. </para>
                        <para>Once you've found a particular Task, you can see its details by clicking on the Link in the <application>Name</application> column. </para>
                        <para>It's also possible to search on the history of the running of Tasks. This is made possible by the <application>Executed Tasks</application>  search, which is accessed by clicking on a task. </para>
                        </section>
                        <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Tasks-Adding_a_New_Task">
                          <title>Adding a new task</title>
                          <para>
                            To add a task it will need to be packaged as an RPM. This requires creating a Makefile (See
                            <xref linkend="User_Guide-Getting_Started-Process-Beaker_Makefile"></xref>).
                            Once you have your task RPM, click <guimenu>Scheduler>New Task</guimenu> from the main menu bar.
                            You will need to click on <guilabel>Browse</guilabel> to locate your task, and then add it
                            with the <guilabel>Submit Data</guilabel> button.
                            See the beaker client <ulink url="http://beaker-project.org/man/bkr-task-add.html">man page</ulink>
                            for how to do this via the beaker client.
                          </para>
                          <para>
                            If you are trying to update an existing task, the version of the new task RPM will need to be higher.
                            This can be achieved by running <command>make tag</command> (if in a local checkout of a git or CVS repo),
                            or manually adjusting the <code>TESTVERSION</code> in the task's Makefile (See
                            <xref linkend="User_Guide-Getting_Started-Process-Beaker_Makefile-TESTVERSION"></xref>).
                          </para>
                        </section>
                    </section>
                    <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Reports">
                      <title>Reports</title>
                    <para>Beaker offers a few different reports. They can be accessed from the Reports menu at the top of the page. The Reserve report will give reservation details of Systems that are currently in use. The other report offered is the Matrix report.     </para>
                   <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Reports-Matrix_Report">
                    <title>Matrix Report</title>
                      <para>The <application>Matrix</application> report gives a user an overall picture of results for any given Job, or number of Jobs combined. It shows a matrix of Tasks run and the Arch that they were run on. The <application>Reports->Matrix</application> is accesable from the top menu. </para>
                      <mediaobject>
                           <imageobject>
                               <imagedata fileref="./images/report_matrix.png" format="PNG" scalefit="1" width="444" />
                            </imageobject>
                          <caption>Generating a Matrix report from the Job's Whiteboard</caption>
                      </mediaobject>
                      <para>There are two ways of defining what Job results to display. You can select the Job by its <application>Whiteboard</application>, or by its <application>Job ID</application>.
                            To show a Job's Matrix report from its Whiteboard, click on the Whiteboard text in the <application>Whiteboard</application> select box
                            (or select multiple whiteboards with the <emphasis>Ctrl</emphasis> key). If you wish to select the Job by its ID, enter the Job ID into the <application>Job ID</application>  text area.
                            The Job Whiteboard and the Job ID are mutually exclusive when generating the Matrix report. To change between the two, click on their respective input areas.
                            Click the <application>Generate</application> button to create the report.
                      </para>
                      <note>
                        <title>Filtering Whiteboards</title>
                          <para>You can filter what is displayed in the <application>Whiteboard</application> select box by typing text into the <application>Filter by</application> field, and then clicking the
                            <emphasis>Filter</emphasis> button
                          </para>
                      </note>
                      <note>
                        <title>Displaying reports of any combination of Jobs</title>
                        <para>Displaying the Matrix reports of any Jobs together, is possible when selecting by <application>Job ID</application>. Enter in all the relevant <application>Job IDs</application> seperate by whitespace or a newline.
                         </para>
                      </note>
                      <mediaobject>
                           <imageobject>
                               <imagedata fileref="./images/report_matrix_generate.png" format="PNG" scalefit="1" width="444" />
                            </imageobject>
                            <caption>Generating a Matrix report from the Job ID</caption>
                      </mediaobject>
                      <para>The generated Matrix report shows the result of each Task with its corresponding Arch and Recipe Whiteboard. The points in the matrix describe the result of the Task, and how many occurences of that result there are. Clicking on these results will take you to the <application>Executed Tasks</application> page. See Section 5.5.2, “Task Searching”. 
                       </para>
                      <mediaobject>
                           <imageobject>
                               <imagedata fileref="./images/report_matrix_results.png" format="PNG" scalefit="1" width="444" />
                            </imageobject>
                            <caption>Viewing the result of one or more Jobs via the Matrix report</caption>
                      </mediaobject>
                      </section>
                    </section>
                    <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Groups">
                    <title>Groups</title>
                    <para>To have one or more <application>Users</application> grouped together, Beaker uses <application>Groups</application>. Systems can belong to one or more Groups. </para>
                    <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Groups-Adding_a_Group">
                    <title>Adding a Group</title>
                    <para>Groups can only be created by a User in the <application>Admin Group</application>. To add a new Group go to <application>Admin->Groups</application> and click the <application>Add( + )</application> link at the bottom left. You'll then be prompted to enter a <application>Display Name</application> and a <application>Group Name</application>. The former is the name that users of Beaker will see, and the latter is the name used internally. It's fine to have these names the same, or different. </para>
                    </section>
                    <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Groups-Editing_a_Group">
                    <title>Editing a Group</title>
                    <para>To edit Group go to <application>Admin->Groups</application> and click on the name of the Group you wish to edit. From here you can add Users, Systems, Permisions as well as the
                      Display Name and Group Name of the Group</para>
                    </section>

                      <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Groups-Group_Activity">
                        <title>Group Activity</title>
                          <para>To search through the historical activity of all Groups, navigate to <application>Activity&gt;Groups</application> at the top of the page. The default search is <application>contains</application> on the <application>Property</application> attribute. 
                          </para>
                      </section>
                    </section>
                    <section id="User_Guide-Getting_Started-Process-Beaker_Interface-Preferences">
                        <title>User Preferences</title>
                        <para>The preferences page allows the user to configure their email address, SSH public keys and root password for provisioned systems.</para>
                        <para>Either a hashed password (in crypt format) or a cleartext password may be entered as a root password.
                              If a plaintext password is entered, it will first be hashed before being stored.
                              This password will be used as the root password on systems provisioned by the user.
                        </para>
                        <para>If Beaker is configured to limit the validity of users' root passwords,
                              the expiry date and time for your password will be shown here.
                              After that time, you will be required to change or clear it in order to submit jobs or provision systems.
                        </para>
                        <para>If no password is entered, the Beaker default root password will be used instead.
                        </para>
                        <para>SSH public keys (e.g. the contents of <filename>~/.ssh/id_rsa.pub</filename>) may be added to a users account.
                              These will be added to the <filename>authorized_keys</filename> file for the root user on provisioned hosts.
                        </para>
                    </section>
                    </section>
