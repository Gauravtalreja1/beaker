<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="Administration">
<title>Administration Guide</title>
		<section id="Administration-Scope_of_Document">
		  <title>Scope of Document</title>
		  <para>
		    The document is aimed at experienced system administrators with basic understanding of Linux based testing tools. This section provides general Beaker overview information. Here you will find descriptions of the Beaker components, Beaker architecture, Beaker server and target host comparisons, and platform requirements. 
		  </para>
    </section>
    <section id="Administration-Beaker_Architecture">
      <title>Beaker Architecture </title>
        <para>
         Beaker is an automated software testing application that allows users to create and manage customized 'tests'. A task is  a script that performs a specific task (or multiple tasks) and presents these task results to the user. These tasks consist of code, data, meta data, shell scripts, hooks to other code, and additional packages (or dependencies). Beaker uses an interactive user environment that is composed of API libraries, template files, and various tools.  
        </para>
        <para>
        Beaker is composed of several components, but the Beaker environment is what users employ to create and run the tests. Software developers may compose tests remotely, and then use Beaker to deploy the test scripts in a test lab environment, where they will ultimately run on a dedicated test host(s). The developer uses the command line to configure Beaker and the generated output data collects to the <application>stdout</application> stream. Beaker stores the generated output data into a repository which users can can view via the Beaker GUI application.
        </para>
        <para>
        Software developers can deploy their tests into several automatic testing environments. They can run the tests in a real lab environment. They can run tests on their development machine's fake chroot tree. They should run their tests in a typical test lab environment, since this allows for automatic test scheduling and advanced test results collection (on many different operating systems and architectures). Also, the test lab environment is more likely to detect, report, and catalog system errors. This guide describes how to compose tests in a Beaker test lab environment.  
        </para>
        <para>
          After developers create a new test, they can package it as a typical RPM file and submit it to the repository, where other users may download it. The Beaker file organization is very flexible, and this allows them to create highly complex tests. This flexibility allows developers to include more shell scripts, source code, or data files into their tests. 
        </para>
    </section>
    <section id="Administration-Test_Scheduler ">
      <title>Test Scheduler </title>
        <para>
        The Beaker test scheduler coordinates the target host machines that run the tests. This Beaker component manages machine selection. The Beaker test scheduler manages tests that requires multiple hosts to  communicate. This Beaker component determines when and how the tests are launched. 
        </para>
    </section>
    <section id="Administration-Audience">
      <title>Audience</title>
        <para>
        The Beaker test scheduler coordinates the target host machines that run the tests. This Beaker component manages all test execution functions including machine selection, distribution installation, and fencing. The Beaker test scheduler manages tests that requires multiple hosts to communicate. This Beaker component determines when and how the tests are launched.  
        </para>
           </section>
     <section id="Administration-Database ">
      <title>Database </title>
        <para>
        The Beaker database coordinates all Beaker functions that require storage. This Beaker component allows users to manage an unlimited number of tests they can create and deploy on your organization's target hosts. An installation program installs the database on the Beaker server, and the db sends the test system data to the Beaker GUI (Graphical User Interface) application where it is viewable in the respective area. Beaker uses the open source MySQL database.
        </para>
    </section>
    <section id="Administration-Chronological_Overview">
      <title>Chronological Overview </title>
        <para>
        This section describes how a user creates a script and integrates it into the Beaker environment: 
          <itemizedlist>
            <listitem>
              <para>On a workstation, a user writes a script and then tests the code. 
              </para>
            </listitem>
            <listitem>
              <para>The user builds an RPM and submits it to the repository (If they are using one).
              </para>
            </listitem>
            <listitem>
              <para>They add their test to Beaker's task library.
              </para>
            </listitem>
            <listitem>
              <para>They create a job that uses the task.
              </para>
            </listitem>
            <listitem>
              <para>The scheduler then sends the data to the target host lab controller, which installs the operating systems and developer tests onto the target hosts.
              </para>
            </listitem>
            <listitem>
              <para>These target hosts boot into the respective operating system and runs the test(s)
              </para>
            </listitem>
            <listitem>
              <para>The test results are sent back to the scheduler for reporting. 
              </para>
            </listitem>
            <listitem>
              <para>Lastly, the scheduler uses email to notify the users' of their test results.
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <mediaobject>
										<imageobject>
											<imagedata fileref="./images/chronological_overview.png" format="PNG" scalefit="1" width="444" />
										</imageobject>
										<caption><para>Chronological Overview</para></caption>
								</mediaobject>
    </section>
    <section id="Administration-Server_And_Target_Host_Relationship">
      <title>Server And Target Host Relationship</title>
        <para>
       The Beaker RPMs installs the packages to the Beaker server and to as many target hosts as your organization requires. The Beaker server side contains software components that control server and host operations. The Beaker server hosts the MySQL database, the test scheduler, and the repository. The Beaker server also hosts the Beaker GUI application. The Beaker server uses the database to manage the user accounts and store the test results. Software developers can write tests scripts from their workstation, and use the Beaker server's tools to deploy their test scripts as RPMs. 
        </para>
        <mediaobject>
										<imageobject>
											<imagedata fileref="./images/beaker_server_host.png" format="PNG" scalefit="1" width="444" />
										</imageobject>
										<caption><para>Server And Target Host Relationship</para></caption>
								</mediaobject>
        <para>
        However, the server does not run the tests. They are actually run on the target hosts. When a test is run, the target host reports the results back to the Beaker server. Users can have multiple target hosts, as each is treated as a clean system. The target host must be a dedicated machine with no other jobs pending. There is no permanent storage on the target hosts because each host installation overwrites all existing content on that machine. 
        </para>
    </section>
    <section id="Administration-System_Requirements">
      <title>System Requirements</title>
        <para>
        There are separate system requirements for the Beaker server and target hosts. Due to the large number of test files that users can store in the database, Beaker requires a multiple terabyte disk storage system.
        </para>
        <para>
       Your Beaker server should have:
          <itemizedlist>
            <listitem>
              <para>Red Hat Enterprise Linux 5 or latest Fedora operating system. 
              </para>
            </listitem>
            <listitem>
              <para>200 or more gigabytes hard disk space. 
              </para>
            </listitem>
            <listitem>
              <para>4 or more gigabytes of RAM. 
              </para>
            </listitem>
            <listitem>
              <para>4 or more CPUS running at 2.5Ghz or higher. 
              </para>
            </listitem>
            <listitem>
              <para>2 or more terabytes tree storage requirement. 
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <note>
          <para>
          If your site already has an existing repository of Red Hat install trees, you do not have to meet the tree storage requirement above. 
          </para>
        </note>
        <para>
        Your target hosts are required to have: 
          <itemizedlist>
            <listitem>
              <para>Network connectivity to a system running a DHCP server.
              </para>
            </listitem>
            <listitem>
              <para>Network booting capability (like PXE or Netboot). 
              </para>
            </listitem>
            <listitem>
              <para>Serial console logging support using a Target Host's management adapter or a terminal server such as the Avocent ACS series.
              </para>
            </listitem>
            <listitem>
              <para>KVM support. 
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
        Your target hosts to need include a power controller. Here are some the most common compatible controllers that are available: 
          <itemizedlist>
            <listitem>
              <para>HP iLO 
              </para>
            </listitem>
            <listitem>
              <para>Dell DRAC 
              </para>
            </listitem>
            <listitem>
              <para>WTI Boot bars 
              </para>
            </listitem>
            <listitem>
              <para>IPMI 1.5 (or higher) 
              </para>
            </listitem>
            <listitem>
              <para>APC 
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
        You may mix and match any of these controllers on the target hosts, but you must include at least one of per machine. Beaker supports the cman package's fence component. Beaker supports any device that you control from the Red Hat Enterprise Linux 5 command line. 
        </para>
    </section>

<section id="Administration-Customizing_Kickstarts">

<title>Customizing Kickstarts</title>

<para>When Beaker provisions a system, the Beaker server generates an Anaconda
kickstart from a template file. Beaker’s kickstart templates are written in the
Jinja2 templating language. Refer to the <ulink
url="http://jinja.pocoo.org/docs/">Jinja2 documentation</ulink> for details of
the template syntax and builtin constructs which are available to all
templates.</para>

<para>Beaker selects a base kickstart template according to the major version 
of the distro being provisioned, for example <literal>Fedora16</literal> or 
<literal>RedHatEnterpriseLinux6</literal>. If no template is found under this 
name, Beaker will also try the major version with trailing digits stripped 
(<literal>Fedora</literal>, <literal>RedHatEnterpriseLinux</literal>).</para>

<para>The Beaker server searches the following directories for kickstart
templates, in order:
<itemizedlist>
  <listitem>
    <para><filename>/etc/beaker/kickstarts</filename></para>
    <para>Custom templates may be placed here.</para>
  </listitem>
  <listitem>
    <para><filename>/usr/lib/python2.6/site-packages/bkr/server/kickstarts</filename></para>
    <para>These templates are packaged with Beaker and should not be 
    modified.</para>
  </listitem>
</itemizedlist>
</para>

<para>Beaker ships with kickstart templates for all current Fedora and Red Hat 
Enterprise Linux distros. The shipped templates include all the necessary parts 
to run Beaker scheduled jobs. They also provide a mechanism for customizing the 
generated kickstarts with template "snippets". Administrators are recommended 
to use custom snippets where necessary, rather than customizing the base 
templates.</para>

<section id="Administration-Kickstart_Snippets">

<title>Kickstart Snippets</title>

<para>Each snippet provides a small unit of functionality within the kickstart. 
The name and purpose of all defined snippets are given below.</para>

<para>For the following snippets Beaker ships a default template, which should 
be sufficient in most cases. However, administrators may choose to override 
these if necessary.</para>

<variablelist>
  <varlistentry>
    <term><filename>anaconda_repos</filename></term>
    <term><filename>print_anaconda_repos</filename></term>
    <listitem>
      <para>Provides the <command>repo</command> kickstart commands which 
      tell Anaconda where to find the distro tree’s Yum repositories for 
      installation.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><filename>install_method</filename></term>
    <listitem>
      <para>Provides the <command>url</command> or <command>nfs</command> 
      kickstart command which tells Anaconda where to find the distro 
      tree for installation.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><filename>lab_env</filename></term>
    <listitem>
      <para>Sets environment variables on the installed system, giving 
      the address of various services within the lab. The exact name and 
      meaning of the environment variables are left up to the 
      administrator, but may include for example build servers, download 
      servers, or temporary storage servers.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><filename>post_s390_reboot</filename></term>
    <listitem>
      <para>Reportedly this does not work and should probably be 
      deleted.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><filename>pre_anamon</filename></term>
    <term><filename>post_anamon</filename></term>
    <listitem>
      <para>Configures <application>anamon</application>, a small daemon 
      which runs during the Anaconda install process and uploads log 
      files to the Beaker scheduler.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><filename>print_repos</filename></term>
    <listitem>
      <para>Sets up the system’s Yum repo configuration after 
      install.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><filename>readahead_packages</filename></term>
    <term><filename>readahead_sysconfig</filename></term>
    <listitem>
      <para>Disables readahead, which is known to conflict with 
      auditd.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><filename>rhts_devices</filename></term>
    <term><filename>rhts_scsi_ethdevices</filename></term>
    <listitem>
      <para>Provides <command>device</command> commands (if 
      necessary) which tell Anaconda to load additional device 
      modules.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><filename>rhts_packages</filename></term>
    <listitem>
      <para>Provides a list of packages to be installed by Anaconda, 
      based on the packages required by and requested in the 
      recipe.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><filename>rhts_pre</filename></term>
    <term><filename>rhts_post</filename></term>
    <listitem>
      <para>Scripts necessary for running a Beaker recipe on the system 
      after it is provisioned. These should never be overriden by the 
      administrator.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><filename>ssh_keys</filename></term>
    <listitem>
      <para>Adds the Beaker user’s SSH public keys to 
      <filename>/root/.ssh/authorized_keys</filename> after installation, 
      so that they can log in using SSH key authentication.</para>
    </listitem>
  </varlistentry>
</variablelist>

<para>The following snippets have no default template, and will be empty unless 
customized by the administrator:</para>

<variablelist>
  <varlistentry>
    <term><filename>network</filename></term>
    <listitem>
      <para>Provides extra network configuration parameters for 
      Anaconda.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><filename>system</filename></term>
    <term><filename><replaceable>distro_major_version</replaceable></filename></term>
    <listitem>
      <para>Can be used to insert extra Anaconda commands into the main 
      section of the kickstart.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><filename>system_pre</filename></term>
    <term><filename><replaceable>distro_major_version</replaceable>_pre</filename></term>
    <listitem>
      <para>Can be used to insert extra shell commands into the %pre 
      section of the kickstart.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><filename>system_post</filename></term>
    <term><filename><replaceable>distro_major_version</replaceable>_post</filename></term>
    <listitem>
      <para>Can be used to insert extra shell commands into the %post 
      section of the kickstart.</para>
    </listitem>
  </varlistentry>
</variablelist>

<para>When a snippet is included in a kickstart template, Beaker tries to load 
the snippet from the following locations on the server’s filesystem, in order:
<itemizedlist>
  <listitem>
    <para><filename>/etc/beaker/snippets/per_system/<replaceable>snippet_name</replaceable>/<replaceable>system_fqdn</replaceable></filename></para>
  </listitem>
  <listitem>
    <para><filename>/etc/beaker/snippets/per_lab/<replaceable>snippet_name</replaceable>/<replaceable>labcontroller_fqdn</replaceable></filename></para>
  </listitem>
  <listitem>
    <para><filename>/etc/beaker/snippets/per_osversion/<replaceable>snippet_name</replaceable>/<replaceable>distro_version</replaceable></filename></para>
  </listitem>
  <listitem>
    <para><filename>/etc/beaker/snippets/per_osmajor/<replaceable>snippet_name</replaceable>/<replaceable>distro_major_version</replaceable></filename></para>
  </listitem>
  <listitem>
    <para><filename>/etc/beaker/snippets/<replaceable>snippet_name</replaceable></filename></para>
  </listitem>
  <listitem>
    <para><filename>/usr/lib/python2.6/site-packages/bkr/server/snippets/<replaceable>snippet_name</replaceable></filename></para>
  </listitem>
</itemizedlist>
This allows administrators to customize Beaker kickstarts at whatever level is 
necessary.</para>

<para>For example, if the system <systemitem 
class="fqdomainname">host01.example.com</systemitem> needs to use a network 
interface other than the default, the following snippet could be placed in 
<filename>/etc/beaker/snippets/per_system/network/host01.example.com</filename>:

<programlisting>
network --device eth1 --bootproto dhcp --onboot yes
</programlisting>
</para>

</section>

<section id="Administration-Writing_Kickstart_Templates">

<title>Writing Kickstart Templates</title>

<para>All kickstart metadata variables are exposed as template variables. 
The <varname>system</varname>, <varname>distro</varname>, 
<varname>distro_tree</varname>, <varname>user</varname>, and 
<varname>recipe</varname> variables are the corresponding Beaker model objects 
loaded from the database. (User templates do not have access to these model 
objects.)</para>

<para>In addition to the built-in template constructs provided by Jinja, the 
following utilities are available in templates:</para>

<variablelist>
  <varlistentry>
    <term><varname>end</varname></term>
    <listitem>
      <para>A variable which contains the string <literal>%end</literal> 
      if the version of Anaconda requires it, otherwise undefined. For 
      compatibility across all Anaconda versions, templates should always 
      terminate sections with this variable. For example:
      <programlisting>
%post
echo "All done."
{{ end }}
      </programlisting>
      </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><varname>parsed_url</varname></term>
    <listitem>
      <para>A Jinja filter which parses a URL using <ulink 
      url="http://docs.python.org/library/urlparse.html#urlparse.urlparse"><function>urlparse.urlparse</function></ulink>.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><varname>re</varname></term>
    <listitem>
      <para>The Python <ulink 
      url="http://docs.python.org/library/re.html">re</ulink> module, for 
      evaluating regular expressions.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><varname>snippet</varname></term>
    <listitem>
      <para>A function which evaluates the named snippet and returns the 
      result. If no template is found for the snippet, returns a comment 
      to that effect.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><varname>split</varname></term>
    <listitem>
      <para>A Jinja filter which splits on whitespace, or any other 
      delimiter. See <ulink 
      url="http://docs.python.org/library/string.html#string.split"><function>string.split</function></ulink>.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><varname>arch</varname></term>
    <term><varname>osmajor</varname></term>
    <term><varname>osversion</varname></term>
    <listitem>
      <para>These are Jinja tests which can be applied to 
      <varname>distro_tree</varname>. Each takes multiple arguments, and 
      evaluates to true if the distro tree matches one of the arguments. 
      For example:</para>
      <programlisting>
{% if distro_tree is arch('s390', 's390x') %}
<replaceable>...</replaceable>
      </programlisting>
      <programlisting>
{% if distro_tree is osversion('RedHatEnterpriseLinux6.0') %}
<replaceable>...</replaceable>
      </programlisting>
      <programlisting>
{% if distro_tree is osmajor('RedHatEnterpriseLinux3', 'RedHatEnterpriseLinux4') %}
<replaceable>...</replaceable>
      </programlisting>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><varname>urljoin</varname></term>
    <listitem>
      <para>A Jinja filter which resolves a relative URL against a base 
      URL. For example:
      <programlisting>
{{ 'http://example.com/distros/'|urljoin('RHEL-6.2/') }}
      </programlisting>
      will evaluate to 
      <literal>http://example.com/distros/RHEL-6.2/</literal> in the 
      kickstart.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><varname>var</varname></term>
    <listitem>
      <para>A function which looks up a variable by name.</para>
    </listitem>
  </varlistentry>
</variablelist>

</section>

</section>

<section id="Administration-Customizing_Power_Commands">

<title>Customizing Power Commands</title>

<para>When executing a power command (for example, rebooting a system) the
Beaker lab controller looks for an executable script named after the system’s
power type (for example, <literal>ipmitool</literal>). The following
directories are searched on the lab controller, in order:
<itemizedlist>
  <listitem>
    <para><filename>/etc/beaker/power-scripts</filename></para>
    <para>Custom power scripts may be placed here.</para>
  </listitem>
  <listitem>
    <para><filename>/usr/lib/python2.6/site-packages/bkr/labcontroller/power-scripts</filename></para>
    <para>These templates are packaged with Beaker and should not be 
    modified.</para>
  </listitem>
</itemizedlist>
</para>

<para>When a script is found it is executed with the following environment
variables set according to the system’s power settings in Beaker:
<itemizedlist>
  <listitem>
    <para><envar>power_address</envar></para>
  </listitem>
  <listitem>
    <para><envar>power_id</envar></para>
  </listitem>
  <listitem>
    <para><envar>power_user</envar></para>
  </listitem>
  <listitem>
    <para><envar>power_pass</envar></para>
  </listitem>
</itemizedlist>
Additionally, the <envar>power_mode</envar> environment variable will be set to
either <literal>on</literal> or <literal>off</literal>, depending on the power
action.</para>

</section>

    </chapter>
<!-- vim: set sw=2 : -->
