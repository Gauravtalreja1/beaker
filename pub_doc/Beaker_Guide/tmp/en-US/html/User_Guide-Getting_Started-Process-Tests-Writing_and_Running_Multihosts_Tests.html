<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3.2.1.4.2. Writing and Running Multihosts Tasks</title><link rel="stylesheet" href="Common_Content/css/default.css" type="text/css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 2.5" /><meta name="package" content="Beaker-Deployment_Guide-0.5-en-US-1-9" /><link rel="home" href="index.html" title="Deployment Guide" /><link rel="up" href="User_Guide-Getting_Started-Process-Tests.html" title="3.2.1.4. Tests" /><link rel="prev" href="User_Guide-Getting_Started-Process-Tests-Test_Architecture_Considerations.html" title="3.2.1.4.1. Test Architecture Considerations" /><link rel="next" href="User_Guide-Getting_Started-Process-Tests-Writing_and_Running_Multihosts_Tests-Synchronization_Commands.html" title="3.2.1.4.2.1. Synchronization Commands" /></head><body><p id="title"><a class="left" href="https://fedorahosted.org/publican"><img src="Common_Content/images/image_left.png" alt="Product Site" /></a><a class="right" href="https://fedorahosted.org/publican"><img src="Common_Content/images/image_right.png" alt="Documentation Site" /></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="User_Guide-Getting_Started-Process-Tests-Test_Architecture_Considerations.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="User_Guide-Getting_Started-Process-Tests-Writing_and_Running_Multihosts_Tests-Synchronization_Commands.html"><strong>Next</strong></a></li></ul><div xml:lang="en-US" class="section" id="User_Guide-Getting_Started-Process-Tests-Writing_and_Running_Multihosts_Tests" lang="en-US"><div class="titlepage"><div><div><h5 class="title" id="User_Guide-Getting_Started-Process-Tests-Writing_and_Running_Multihosts_Tests">3.2.1.4.2. Writing and Running Multihosts Tasks</h5></div></div></div><div class="para">
		All of the examples so far have run on a single host. Beaker has support for tasks that run on multiple hosts, e.g. for testing the interactions of a client and a server.
	</div><div class="para">
		When a multihost task is run in the lab, a machine will be allocated to each role in the test. Each machine has its own recipe.
	</div><div class="para">
		Each machine under test will need to synchronize to ensure that they start the test together, and may need to synchronize at various stages within the test. Beaker has three notional roles: client, server and driver.
	</div><div class="para">
		For many purposes all you will need are client and server roles. For a test involving one or more clients talking to one or more servers, a typical approach would be for the clients to block whilst the servers get ready. Once all servers are ready, the clients perform whatever testing they need, using the services provided by the server machines, and eventually report results back to the test system. Whilst this is happening the server tests block; the services running on these machines are carrying out work for the clients in parallel. Once all clients have finished testing, the server tests finish, and report their results.
	</div><div class="para">
		Each participant in a test will be reporting results within the same job, and so must report to different places within the result hierarchy. For example, the server part of the test may PASS if it survives the load, but the client part might FAIL upon, say, getting erroneous data from the server; this would lead to an overall FAIL for the test.
	</div><div class="para">
		If you have a more complex arrangement, it is possible to have a driver machine which controls all of the testing.
	</div><div class="para">
		All of the participants in a multihost test share a single <span class="application"><strong>runtest.sh</strong></span>, which must perform every role within the test (e.g. the client role and server role). When a multihost test is run in the lab, the framework automatically sets environment variables to allow the various participants to know what their role should be, which other machines they should be talking to, and what roles those other machines are performing in the test. You will need to have logic in your<span class="application"><strong> runtest.sh</strong></span> to examine these variables, and perform the necessary role accordingly. These variables are shared by all instances of the runtest.sh within a recipeset: 
		<div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="application"><strong>CLIENTS</strong></span> contains a space-separated list of hostnames of clients within this recipeset.
				</div></li><li class="listitem"><div class="para">
					<span class="application"><strong>SERVERS</strong></span> contains a space-separated list of hostnames of servers within this recipeset.
				</div></li><li class="listitem"><div class="para">
					<span class="application"><strong>DRIVER</strong></span> is the hostname of the driver of this recipeset, if any.
				</div></li></ul></div>

	</div><div class="para">
		The variable HOSTNAME can be used by runtest.sh to determine its identity. It is set by beaker-environment.sh, and will be unique for each host within a recipeset.
	</div><div class="para">
		Your test can thus decide whether it is a client, server or driver by investigating these variables: see the example below.
	</div><div class="para">
		When you are developing your test outside the lab environment, only HOSTNAME is set for you (when sourcing the beaker-environment.sh script). Typically you will copy your test to multiple development machines, set up CLIENTS, SERVERS and DRIVER manually within a shell on each machine, and then manually run the runtest.sh on each one, debugging as necessary.
	</div><div class="para">
		A multihost test needs to be marked as such in the<span class="emphasis"><em> Type: Multihost</em></span>.
	</div><div class="para">
		In it's simplest form, a job with multihost testing can look like:
	</div><pre class="screen">&lt;job&gt;
  &lt;RecipeSet&gt;
     &lt;recipe&gt;
        &lt;task role='STANDALONE' name='/distribution/install'/&gt;
        &lt;task role='SERVERS' name='/my/multihost/test'/&gt;
     &lt;/recipe&gt;
     &lt;recipe&gt;
        &lt;task role='STANDALONE' name='/distribution/install'/&gt;
        &lt;task role='CLIENTS' name='/my/multihost/test'/&gt;
     &lt;/recipe&gt;
  &lt;/RecipeSet&gt;
&lt;/job&gt;</pre><div class="note"><div class="admonition_header"><h2>Note</h2></div><div class="admonition"><div class="para">
			For brevity some necessary parts are left out in the above job description
		</div></div></div><div class="para">
		Submitting the job above will export environmental variables SERVERS and CLIENTS set to their respective hostnames. This allows a tester to write tests for each machines. So the runtest.sh in /my/multihost/test test might look like:
	</div><pre class="screen">Server() {
    # .. server code here
}

Client() {
    # .. client code here
}

if test -z "$JOBID" ; then
    echo "Variable jobid not set! Assume developer mode" 
    SERVERS="test1.example.com"
    CLIENTS="test2.example.com"
    DEVMODE=true
fi

if [ -z "$SERVERS" -o -z "$CLIENTS" ]; then
    echo "Can not determine test type! Client/Server Failed:" 
    RESULT=FAILED
    report_result $TEST $RESULT
fi

if $(echo $SERVERS | grep -q $HOSTNAME); then
    TEST="$TEST/Server"
    Server
fi

if $(echo $CLIENTS | grep -q $HOSTNAME); then
    TEST="$TEST/Client"
    Client
fi</pre><div class="para">
		Let's disect the code. First of, we have Server() and Client() functions which will be executed on SERVERS and CLIENTS machines respectively. Then we have an if block to determine if this is running as an beaker test, or if it's being run on the test developer's machine(s) to test it out. The last couple if blocks determine what code to run on this particular machine. As mentioned before, SERVERS and CLIENTS environmental variables will be set to their respective machines' names and exported on both machines.
	</div><div class="para">
		Obviously, there will have to be some sort of coordination and synchronization between the machines and the execution of the test code on both sides. Beaker offers two utilities for this purpose, rhts-sync-set and rhts-sync-block . rhts-sync-set is used to setting a state on a machine. rhts-sync-block is used to block the execution of the code until a certain state on certain machine(s) are reached. Those familiar with parallel programming can think of this as a barrier operation . The detailed usage information about both of this utilities is below: 
		<div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="application"><strong>rhts-sync-set:</strong></span> It does set the state of the current machine. State can be anything. Syntax: rhts-sync-set -s STATE
				</div></li><li class="listitem"><div class="para">
					<span class="application"><strong>rhts-sync-block:</strong></span> It blocks the code and doesn't return until a desired STATE is set on desired machine(s) . You can actually look for a certain state on multiple machines.. Syntax: rhts-sync-block -s STATE [-s STATE1 -s STATE2] machine1 machine2 ...
				</div></li></ul></div>

	</div><div class="para">
		There are a couple of important points to pay attention. First of, the multihost testing must be on the same chronological order on all machines. For example, the below will fail:
	</div><pre class="screen">
          &lt;recipe&gt;
            &lt;task role='STANDALONE' name='/distribution/install'/&gt;
            &lt;task role='STANDALONE' name='/my/test/number1'/&gt;
            &lt;task role='SERVERS'     name='/my/multihost/test'/&gt;
          &lt;/recipe&gt;
          &lt;recipe&gt;
            &lt;task role='STANDALONE' name='/distribution/install'/&gt;
            &lt;task role='CLIENTS'     name='/my/multihost/test'/&gt;
          &lt;/recipe&gt;
</pre><div class="para">
		This will fail, because the multihost test is the 3rd test on the server side and it's the 2nd test on the client side.. To fix this, you can pad in dummy testcases on the side that has fewer testcases. There is a dummy test that lives in /distribution/utils/dummy for this purpose. So, the above can be fixed as:
	</div><pre class="screen">
          &lt;recipe&gt;
           &lt;task role='STANDALONE' name='/distribution/install'/&gt;
           &lt;task role='STANDALONE' name='/my/test/number1'/&gt;
           &lt;task role='SERVERS'     name='/my/multihost/test'/&gt;
          &lt;/recipe&gt;
          &lt;recipe&gt;
           &lt;task role='STANDALONE' name='/distribution/install'/&gt;
           &lt;task role='STANDALONE' name='/distribution/utils/dummy'/&gt;
           &lt;task role='CLIENTS'     name='/my/multihost/test'/&gt;
          &lt;/recipe&gt;
</pre><div class="para">
		One shortcoming of the rhts-sync-block utility is that it blocks forever, so if there are multiple things being done in your test between the hosts, your test will timeout without possibly a lot of code being executed. There is a utility, blockwrapper.exp which can be used to put a limit on how many second it should block. The script lives in /CoreOS/common test, so be sure to add that test before your multihost tests in your recipes. The usage is exactly same as that of rhts-sync-block with the addition of a timeout value at the end, i.e.:
	</div><pre class="screen">
                    blockwrapper.exp -s STATE machine N 
</pre><div class="para">
		where N is the timeout value in seconds. If the desired state in the desired machine(s) haven't been set in N seconds, then the script will exit with a non-zero return code. In case of success it'll exit with code 0 .
	</div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="User_Guide-Getting_Started-Process-Tests-Test_Architecture_Considerations.html"><strong>Prev</strong>3.2.1.4.1. Test Architecture Considerations</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="User_Guide-Getting_Started-Process-Tests-Writing_and_Running_Multihosts_Tests-Synchronization_Commands.html"><strong>Next</strong>3.2.1.4.2.1. Synchronization Commands</a></li></ul></body></html>
