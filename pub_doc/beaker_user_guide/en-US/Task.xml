<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "beaker_user_guide.ent">
%BOOK_ENTITIES;
]>
<section id="chap-beaker_user_guide-Components-Tasks">
	<title>Tasks</title>
	<para>
        Tasks are the lowest unit in the Job hierarchy, and running a Task is the primary purpose of running a Job.
        There purpose is to run one or more commands, and then collect the results of those commands in a way that other entities can access them.
	You can run as many or as few Tasks in a Job as you like. 
	</para>
        
	<section id="sect-beaker_user_guide-Components-Tasks-Task_Create">
		<title>Creating a Task</title>
		<para>
			To create Tasks the <literal>rhts-devel</literal> package will need to be installed. From your terminal, type: 
<screen>
$ <userinput>yum install rhts-devel</userinput>
</screen>
			 Now make a new directory from where you will create the test. Then <literal>cd</literal> into the newly created folder and run the following: 
<screen>
$ <userinput>rhts-create-new-test</userinput>
$ <userinput>ls -l</userinput>
Makefile  PURPOSE  runtest.sh
</screen>
			 Below is a rundown of the files created and how to use them
		</para>
		<formalpara>
			<title>runtest.sh</title>
			<para>
				The core of each RHTS test is a <filename>runtest.sh</filename> shell script. It performs the testing (or delegates the work by invoking another script or executable) and reports the results. Either write the code that performs the test in the runtest.sh shell script or have runtest.sh execute another program that does the bulk of the work in perhaps another language. Choose a language appropriate to the job (and with which you are familiar): testing of a library could be written in C, parsing of text streams could be done in Perl, and GUI scripting in Python. Languages can be mixed and matched as appropriate within a single test - the <filename>runtest.sh</filename> script can call other code as necessary. Aim for correctness and readability: remember that others may have to debug this code if a test is flawed. Here is the example <filename>runtest.sh</filename>: 
<screen>
#!/bin/sh

# Copyright (c) 2006 Red Hat, Inc. All rights reserved. This copyrighted
# material  is made available to anyone wishing to use, modify, copy, or
# redistribute it subject to the terms and conditions of the GNU General
# Public License v.2.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation, Inc., 
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,USA.

# Author: Your Name &lt;Your Email&gt;

rhts-run-simple-test $TEST ./do-my-test.sh
</screen>
				 The <filename>do-my-test.sh</filename> is a rather simple test, seen below, just enough to illustrate the required components of a task. 
<screen>
#!/bin/sh
# simple test example

ls -al /root/.ssh
</screen>
				 The exit code from listing the contents of <literal>/root/.ssh</literal> will be saved to the <varname>$?</varname> system variable and based on this, <filename>rhts-run-simple-test</filename> will report the failure or success of the Task. So the most basic RHTS coding requirements are that a shell script must be sourced (<filename>rhts-environment.sh</filename>) and the report_result API must be called (this is called in <filename>rhts-run-simple-text</filename>).The output was sent to $<varname>OUTPUTFILE</varname> (in <filename>rhts-environment.sh</filename>). The RHTS API provides the $<varname>OUTPUTFILE</varname> variable so each test can create a log file to record its activities. When run from the command line, $<varname>OUTPUTFILE</varname> points to a temporary file in <filename>/tmp</filename>. When run in a test lab environment, the logs are stored in a central location. The report_result method is always called to inform the RHTS API of the success or failure of the test.
			</para>
		</formalpara>
		<formalpara>
			<title>Makefile</title>
			<para>
				A standard RHTS Makefile coordinates many aspects of developing and running a RHTS test: 
				<itemizedlist>
					<listitem>
						<para>
							compiling test executables.
						</para>
					</listitem>
					<listitem>
						<para>
							packaging test files into a single RPM.
						</para>
					</listitem>
					<listitem>
						<para>
							downloading external source files for use in the test.
						</para>
					</listitem>
					<listitem>
						<para>
							collect test files into a known location for execution.
						</para>
					</listitem>
					<listitem>
						<para>
							running tests
						</para>
					</listitem>
				</itemizedlist>
				 A sample Makefile is copied into the local directory when rhts-create-new-test tool is invoked (or can be found at <filename>/usr/share/doc/rhts-devel-2.6/Makefile.template</filename>). The Makefile sets up certain targets and defines variables necessary for test execution and reporting. It is best to use this example when writing a new test, copying and modifying it as necessary. So for example, in order to have an executable compiled by the Makefile, the following two lines were changed. 
<screen>
BUILT_FILES=do-my-test
FILES=$(METADATA) runtest.sh Makefile PURPOSE do-my-test.c
</screen>
				 When <literal>make run</literal> is typed, the Makefile will compile <filename>do-my-test.c<filename>into</filename>do-my-test</filename> and run runtest.sh, which will then execute <filename>do-my-test</filename>. You do not have to enter anything in the <literal>BUILT_FILES</literal> directive if you are not compiling an executable. Also be sure to fill in the following section: 
<screen>
# The toplevel namespace within which the test lives.
# FIXME: You will need to change this:
TOPLEVEL_NAMESPACE=

# The name of the package under test:
# FIXME: you wil need to change this:
PACKAGE_NAME=

# The path of the test below the package:
# FIXME: you wil need to change this:
RELATIVE_PATH=
</screen>
				 Those three place holders will be used to determine how your Task is named in Beaker, and also how it's mounted on a test System. It will be called /<replaceable>TOPLEVEL_NAMESPACE</replaceable>/<replaceable>PACKAGE_NAME</replaceable>/<replaceable>RELATIVE_PATH</replaceable> and it will be mounted the same in the <filename>/mnt/tests</filename> directory on a test System.
			</para>
		</formalpara>
		<formalpara>
			<title>PURPOSE</title>
			<para>
				The test code directory contains a plain text file called <filename>PURPOSE</filename> which explains what the test addresses along with any other information useful for troubleshooting or understanding it better. The <filename>PURPOSE</filename> file has no minimum or maximum length but should provide useful information. For example: 
<screen>
$ <userinput>cat PURPOSE</userinput>
This trivial test compiles a .c file, runs the resulting code, and checks
that the output is as expected.

It is intended as a simple example of how to write a test that
compiles source code to a binary and reports a single result
using rhts-run-simple-test

It can also be used as a primitive smoketest for the compiler.
</screen>
			</para>
		</formalpara>
		<section id="sect-beaker_user_guide-Components-Tasks-Task_Create-Package">
			<title>Packaging</title>
			<para>
				Before we can add a new Task to Beaker we need to package it. Firstly, you're able to run the task locally (if it makes sense) to ensure that the task operates as expected. If you would like to run the task locally: 
<screen>
$ <userinput>make run</userinput>
chmod a+x ./runtest.sh
./runtest.sh
/tmp/simple_test/do-my-test.sh
Running ./do-my-test.sh  As root: 
total 48
drwx------  2 root root  4096 Dec 15 08:41 .
drwxr-x--- 24 root root 12288 Jun  2 14:57 ..
-rw-------  1 root root   415 Dec 13 19:12 authorized_keys
-rw-r--r--  1 root root  8630 May 25 09:42 known_hosts
...finished running ./do-my-test.sh, exit code=0
/// result: PASS
   Log: /tmp/tmp.c24401
</screen>
				 Once you're happy it works as expected, you can run the following: 
<screen>
$ <userinput>make package</userinput>
</screen>
				 Your Task is now ready to be added to Beaker. 
				<note>
					<title>Tagging</title>
					<para>
						If you wish to, you can increase the version of the package with the following command: 
<screen>
$ <userinput>make tag</userinput>
</screen>
					</para>
				</note>
			</para>
		</section>

	</section>
	<section id="sect-beaker_user_guide-Components-Tasks-Task_Searching">
		<title>Task Searching</title>
		<para>
		To search for a Task, go to <guimenu>Scheduler</guimenu>&gt;<guimenuitem>Task Library</guimenuitem> at the top of the page.
                The default search is on the <literal>Name</literal> property, with the <literal>contains</literal> operator. See <xref linkend="advanced_search" /> for search details.</para>
                <para>Once you've found a particular Task, you can see its details by clicking on the Link in the <literal>Name</literal> column.
		</para>
                  
                <para>
                  It's also possible to search on the history of the running of Tasks. This is made possible by the <literal>Executed Tasks</literal> search, which is accessed by clicking on a task. 
                </para>
         
	</section>
	<section id="sect-beaker_user_guide-Components-Tasks-Task_New"> 
               <title>Adding a new Task</title>
               <para>
               To add a Task which has already been packaged, click <guimenu>Scheduler</guimenu>&gt;<guimenuitem>New Task</guimenuitem>. You will need to click on 
               <literal>Browse</literal> to locate your Task, and then add it with the <literal>Submit Data</literal> button. See also <xref linkend="chap-beaker_user_guide-CLI"/> for adding a task via the beaker client.
               </para>
        </section>
</section>

